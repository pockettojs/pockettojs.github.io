{"searchDocs":[{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. For example, use JSX to create an interactive button: &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"","version":null},{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet... ...consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Here are a few tips you might find useful. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"","version":null},{"title":"ID Generation","type":0,"sectionRef":"#","url":"/docs/data-modelling/id","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"ID Generation","url":"/docs/data-modelling/id#introduction","content":" Pocketto provides a way to generate unique ids for your data. You can set the id method to generate unique ids.  ","version":"Next","tagName":"h3"},{"title":"Set id Method​","type":1,"pageTitle":"ID Generation","url":"/docs/data-modelling/id#set-id-method","content":" import { p } from 'pocketto'; p.setIdMethod('uuid');   Available id methods:  uuid - Generates a unique id via uuidv7, which is sort by time.shortid - Generates a unique id using the shortid package.timestamp - Generates a unique id using the current timestamp. Format: YYYYMMDDHHmmssSSSincrement - Generates a unique id by incrementing the previous id. It is useful for testing purposes.safe-increment - Generates a unique id by incrementing the previous id with timestamp. Format: &lt;RUNNING_NUMBER&gt;-YYYYMMDDHHmmssSSScustom - Generates a unique id using the custom function you provide. ","version":"Next","tagName":"h3"},{"title":"Data Encryption","type":0,"sectionRef":"#","url":"/docs/data-management/encryption","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Encryption","url":"/docs/data-management/encryption#introduction","content":" The encrypt method is used to encrypt the data before storing it in the database. The framework uses the libsodium-wrappers library to encrypt the data.  import { DatabaseManager } from 'pocketto'; DatabaseManager.connect('default', { encryption: true, encryptionPassword: '12345', silentConnect: false, dbName: 'default', adapter: 'idb', });   All the data will be encrypted into payload field, so people will not be able to read the data directly from the database.   ","version":"Next","tagName":"h3"},{"title":"Data Syncing","type":0,"sectionRef":"#","url":"/docs/data-management/data-syncing","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Syncing","url":"/docs/data-management/data-syncing#introduction","content":" The syncDatabases method is used to synchronize the local database with the remote database. This method will fetch the data from the remote database and update the local database.  Assumption This tutorial is assumed that you have already connected to a local database via this tutorial.  import { DatabaseManager, syncDatabases } from 'pocketto'; async function syncWithRemote() { const db = DatabaseManager.get('my-database'); const remoteDb = await DatabaseManager.connect('http://localhost:5984', { dbName: 'remote-database', adapter: 'http', auth: { username: 'admin', password: 'password' }, }); syncDatabases(remoteDb.config.dbName, localDb.config.dbName); await new Promise((resolve) =&gt; { remoteDb.sync(localDb, { live: false, retry: true, continuous: false, }).on(&quot;complete&quot;, () =&gt; { console.log(&quot;Your local database has been fully synced with your remote database!&quot;); resolve(true); }); }); }  ","version":"Next","tagName":"h3"},{"title":"Database Client Tools","type":0,"sectionRef":"#","url":"/docs/database-client-tools","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Database Client Tools","url":"/docs/database-client-tools#introduction","content":" Introduce Poker, a real-time database client tool for Pocketto built with React.  By using this, you may monitor your database in real-time, execute queries, and manage your data with ease.    ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Database Client Tools","url":"/docs/database-client-tools#installation","content":" You can clone and run the Poker tool locally.  git clone git@github.com:pockettojs/pocketto-docs.git cd poker npm install npm run start  ","version":"Next","tagName":"h3"},{"title":"Environment Setup","type":0,"sectionRef":"#","url":"/docs/environment-setup","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Environment Setup","url":"/docs/environment-setup#introduction","content":" Before you start using Pocketto, you need to set up your environment. This guide will help you set up your environment to start using Pocketto.  ","version":"Next","tagName":"h3"},{"title":"Prerequisites​","type":1,"pageTitle":"Environment Setup","url":"/docs/environment-setup#prerequisites","content":" Before you start setting up your environment, make sure you have the following installed:  CouchDB, a real-time NoSQL database that allows you to store your data in local as well as in the cloud.Node.js, version 14 or above is recommended.python. In order to build native modules of npm modules: leveldown, sqlite3, etc.node-gyp  ","version":"Next","tagName":"h3"},{"title":"Platform Installation​","type":1,"pageTitle":"Environment Setup","url":"/docs/environment-setup#platform-installation","content":" Depending on your project platform, you can pick one of the following installation methods:  ReactReact NativeVue.js ","version":"Next","tagName":"h3"},{"title":"Database Manager","type":0,"sectionRef":"#","url":"/docs/data-management/database-manager","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#introduction","content":" The DatabaseManager is a class that provides a set of methods to interact with the database. It is responsible for creating, updating, and deleting records in the database.  import { DatabaseManager } from 'pocketto'; DatabaseManager.connect('default', { encryption: false, silentConnect: false, dbName: 'default', adapter: 'memory', auth: { username: 'admin', password: 'password' }, });   ","version":"Next","tagName":"h3"},{"title":"Slient Connect​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#slient-connect","content":" By default, when connected to the database, it will show a message in the console.    You can disable this message by setting the silentConnect option to true.  DatabaseManager.connect('default', { silentConnect: true, });     ","version":"Next","tagName":"h3"},{"title":"Database Name​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#database-name","content":" You can specify the name of the database by setting the dbName option.  DatabaseManager.connect('default', { dbName: 'my-database', });   Then, you can use DatabaseManager.get() to get the database instance.  const db = DatabaseManager.get('my-database');   ","version":"Next","tagName":"h3"},{"title":"Authentication​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#authentication","content":" You can specify the username and password to authenticate with the remote server.  DatabaseManager.connect('http://localhost:5984', { dbName: 'remote-database', adapter: 'http', auth: { username: 'admin', password: 'password' }, });   ","version":"Next","tagName":"h3"},{"title":"Adapters​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#adapters","content":" The DatabaseManager uses adapters to interact with the database including:  memory: An adapter to store data in memory.idb: An adapter to store data in IndexedDB.leveldb: An adapter to store data in LevelDB.websql: An adapter to store data in WebSQL.http: An adapter to store data in a remote server.  ","version":"Next","tagName":"h3"},{"title":"React Native Adapters​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#react-native-adapters","content":" react-native-sqlite: An adapter to store data in SQLite database in React Native.  ","version":"Next","tagName":"h3"},{"title":"Encryption​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#encryption","content":" For more information on how to encrypt data, see Data Encryption. ","version":"Next","tagName":"h3"},{"title":"Data Sharding","type":0,"sectionRef":"#","url":"/docs/data-management/data-sharding","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Sharding","url":"/docs/data-management/data-sharding#introduction","content":" Data sharding is a method of partitioning data across multiple servers. It is a technique used to distribute data across multiple servers to improve the performance and scalability of the database. Sharding is a common technique used in distributed databases to improve the performance of the database by distributing the data across multiple servers.  To sharding the model data into different databases, you can declare shardingMode in your Model.  import { Model, setMainDatabaseName, ShardingMode } from 'pocketto'; setMainDatabaseName('master'); class SalesInvoice extends Model { static dbName = 'master'; static collectionName = 'SalesInvoices'; static shardingMode = ShardingMode.TimeSeries; invoiceNumber!: string; customerName!: string; remarks?: string; @HasMany('SalesInvoiceItem') items?: SalesInvoiceItem[]; get totalAmount() { return this.items?.reduce((total, item) =&gt; total + item.amount, 0) ?? 0; } }   ","version":"Next","tagName":"h3"},{"title":"Usage - Time Series​","type":1,"pageTitle":"Data Sharding","url":"/docs/data-management/data-sharding#usage---time-series","content":" To use the time series sharding mode, you can set the shardingMode to ShardingMode.TimeSeries.  The database will automatically create a new database for each month when you want to create a instance within the period. The database name will be in the format of master-2021-01, master-2021-02, master-2021-03, and so on.  You can pass in period as the second argument when creating a new instance.  const invoice = await Invoice.create({ invoiceNumber: 'INV-2021-01-001', customerName: 'John Doe', remarks: 'This is a test invoice', items: [ { description: 'Item 1', quantity: 1, price: 100 }, { description: 'Item 2', quantity: 2, price: 200 }, ], }, '2021-01');   You can manage the data by normal query methods.  const savedInvoice = await Invoice.find(invoice.id); savedInvoice.remarks = 'This is a test invoice updated'; await savedInvoice.save();  ","version":"Next","tagName":"h3"},{"title":"Data Conflict","type":0,"sectionRef":"#","url":"/docs/data-management/data-conflict","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#introduction","content":" Under the hoods, pocketto are rely on the field document._meta._rev to trace for the revision of the document.  When a document is updated, the revision number is incremented. This allows pocketto to detect conflicts when two clients try to update the same document at the same time.  When a conflict occurs, pocketto will return a 409 (conflict) error to the client. The client can then resolve the conflict by fetching the latest version of the document, merging the changes, and then trying to update the document again.  ","version":"Next","tagName":"h3"},{"title":"Two Types of Conflicts​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#two-types-of-conflicts","content":" There are two types of conflicts that can occur in the database:  Immediate conflictsEventual conflicts  ","version":"Next","tagName":"h3"},{"title":"Immediate Conflicts​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#immediate-conflicts","content":" Immediate conflicts can occur with any API that using the same ref to store. They manifest as a 409 (conflict) error:  import { SalesInvoice } from 'src/models/SalesInvoice.p'; // 1. Client A create a document call `A` const invoiceA = new SalesInvoice(); invoiceA.id = '1'; invoiceA.number = 'INV-001'; await invoiceA.save(); console.log(invoice._meta._rev); // 1-x // 2. Client B create a document call `A` at the same time try { const invoiceB = new SalesInvoice(); invoiceA.id = '1'; invoiceA.number = 'INV-001'; await invoiceA.save(); } catch (error) { if (err.name !== 'conflict') return; console.log('Conflict happen!:', error); // 409 (conflict) }   warning Normally, _rev look more like 2-c1592ce7b31cc26e91d2f2029c57e621, i.e. a digit followed by a very long hash. In these examples, x and y are used in place of the hash, for simplicity’s sake.  ","version":"Next","tagName":"h3"},{"title":"Eventual Conflicts​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#eventual-conflicts","content":" Eventual conflicts can occur when both clients are fully offline and then come back online. They manifest as a 409 (conflict) error:  const invoiceA = await SalesInvoice.find('1');   Imagine the return are the below:  SalesInvoice { id: &quot;1&quot;, _meta: { _rev: &quot;10-x&quot;, _before_update: {}, _dirty: {} } number: &quot;INV-001&quot;, }   In another client that also fetch the same document, and just connect to the internet and update the document:  const invoiceB = await SalesInvoice.find('1');   SalesInvoice { id: &quot;1&quot;, _meta: { _rev: &quot;10-y&quot;, _before_update: {}, _dirty: {} } number: &quot;INV-002&quot;, }   When the first client try to update the document:  invoiceA.number = 'INV-003'; await invoiceA.save();   The server will return a 409 (conflict) error:  { name: 'conflict', message: 'Document update conflict', status: 409, error: true, reason: 'Document update conflict', revision: '10-y' }   ","version":"Next","tagName":"h3"},{"title":"Solution​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#solution","content":" To handle the conflict, you can do the below step to ensure the document is updated correctly:  Get the latest document via find method.Update the field you wish to replace.Save the document again.  let invoiceA = await SalesInvoice.find('1'); invoiceA.number = 'INV-003'; try { await invoiceA.save(); } catch (error) { if (err.name !== 'conflict') return; // Get the latest document invoiceA = await SalesInvoice.find('1'); // Merge the changes invoiceA.number = 'INV-003'; // Save the document again await invoiceA.save(); }  ","version":"Next","tagName":"h3"},{"title":"Model","type":0,"sectionRef":"#","url":"/docs/data-modelling/model","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#introduction","content":" Pocketto Model allow you to create a model for your data. It is a simple and easy way to create a model for your data.  You can share the model in different platforms, so all the platforms can use the same model with same application logic.  ","version":"Next","tagName":"h3"},{"title":"Define a Model​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#define-a-model","content":" To define a model, you need to create a class that extends the Model class. The Model class is a base class that provides the basic functionality for a model.  In the following example, we define a SalesInvoiceItem model and a SalesInvoice model.  import { Model } from 'pocketto'; @Relational export class SalesInvoiceItem extends Model { static dbName = 'my-database'; static collectionName = 'SalesInvoiceItems'; description!: string; quantity!: number; unitPrice!: number; get amount() { return this.quantity * this.unitPrice; } } @Relational export class SalesInvoice extends Model { static dbName = 'my-database'; static collectionName = 'SalesInvoices'; invoiceNumber!: string; customerName!: string; remarks?: string; @HasMany('SalesInvoiceItem') items?: SalesInvoiceItem[]; get totalAmount() { return this.items?.reduce((total, item) =&gt; total + item.amount, 0) ?? 0; } }   The decorator @Relational is used to define the model as a relational model. The @HasMany decorator is used to define a one-to-many relationship between the SalesInvoice model and the SalesInvoiceItem model.  ","version":"Next","tagName":"h3"},{"title":"Create an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#create-an-instance","content":" To create an instance of a model, you can use the new keyword.  const invoice = new SalesInvoice(); invoice.invoiceNumber = 'INV-001'; invoice.customerName = 'John Doe'; invoice.remarks = 'This is a sample invoice.'; invoice.items = [ { description: 'Item 1', quantity: 2, unitPrice: 100 }, { description: 'Item 2', quantity: 3, unitPrice: 150 }, ];   ","version":"Next","tagName":"h3"},{"title":"Save an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#save-an-instance","content":" To save an instance of a model, you can use the save method.  await invoice.save();   ","version":"Next","tagName":"h3"},{"title":"Find an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#find-an-instance","content":" To find an instance of a model, you can use the find method.  const invoice = await SalesInvoice.find('INV-001');   ","version":"Next","tagName":"h3"},{"title":"Update an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#update-an-instance","content":" To update an instance of a model, you can use the update method.  invoice.update({ remarks: 'This is an updated invoice.', });   ","version":"Next","tagName":"h3"},{"title":"Delete an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#delete-an-instance","content":" To delete an instance of a model, you can use the delete method.  await invoice.delete();  ","version":"Next","tagName":"h3"},{"title":"Query Builder","type":0,"sectionRef":"#","url":"/docs/data-modelling/query-builder","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#introduction","content":" Pocketto Query Builder allows you to build queries for your data. It is a simple and easy way to build queries for your data.  ","version":"Next","tagName":"h3"},{"title":"Build a Query​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#build-a-query","content":" You can utilize Model.query() to build a query. The query() method returns a new instance of the QueryBuilder class.  In the following example, we build a query to get all sales invoices with a total amount greater than 1000.  import { SalesInvoice } from './models'; const invoices = await SalesInvoice.query() .where('totalAmount', '&gt;', 1000) .get();   The where() method is used to add a condition to the query. The first argument is the field name, the second argument is the operator, and the third argument is the value.  If you want to only get the first result, you can use the first() method.  const invoice = await SalesInvoice.query() .where('invoiceNumber', '=', 'INV-001') .first();   ","version":"Next","tagName":"h3"},{"title":"Complex Queries - Chaining​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#complex-queries---chaining","content":" You can build complex queries by chaining multiple where and orWhere.  In the following example, we build a query to get all sales invoices with a total amount greater than 1000 or where the customer name is John Doe.  const invoices = await SalesInvoice.query() .where('totalAmount', '&gt;', 1000) .orWhere('customerName', '=', 'John Doe') .get();   ","version":"Next","tagName":"h3"},{"title":"Complex Queries - Callback​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#complex-queries---callback","content":" You can also able to pass in a callback function to build complex queries.  The callback function receives a QueryBuilder instance as an argument.  import { QueryBuilder } from 'pocketto'; const invoices = await SalesInvoice.query() .where((query: QueryBuilder&lt;SalesInvoice&gt;) =&gt; { query.where('totalAmount', '&gt;', 1000) .orWhere('customerName', '=', 'John Doe'); }) .get();   ","version":"Next","tagName":"h3"},{"title":"Complex Queries - Object​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#complex-queries---object","content":" Or, pass a object to build complex queries.  const invoices = await SalesInvoice.query() .where({ totalAmount: ['&gt;', 1000], customerName: ['=', 'John Doe'], }) .get();   ","version":"Next","tagName":"h3"},{"title":"Sorting​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#sorting","content":" You can sort the results by using the orderBy() method.  const invoices = await SalesInvoice.query() .orderBy('invoiceNumber', 'desc') .get();   The first argument is the field name, and the second argument is the direction (asc or desc).  ","version":"Next","tagName":"h3"},{"title":"Pagination​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#pagination","content":" You can paginate the results by using the paginate() method.  const invoices = await SalesInvoice.query() .paginate(1, 10);   The first argument is the page number, and the second argument is the number of items per page.  ","version":"Next","tagName":"h3"},{"title":"Counting​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#counting","content":" You can count the results by using the count() method.  const count = await SalesInvoice.query() .where('totalAmount', '&gt;', 1000) .count();  ","version":"Next","tagName":"h3"},{"title":"Source Code Protection","type":0,"sectionRef":"#","url":"/docs/extra/source-code-protection","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Source Code Protection","url":"/docs/extra/source-code-protection#introduction","content":" This is a tutorial to guide you how to protect your source code to prevent reverse engineering.  Assumption This tutorial is assumed that you source code are all in src folder, an you have a index.ts file in the root directory of your project. If you have a different structure, you can modify the tsconfig.json file to match your project structure.  ","version":"Next","tagName":"h3"},{"title":"Obfuscation​","type":1,"pageTitle":"Source Code Protection","url":"/docs/extra/source-code-protection#obfuscation","content":" Obfuscation is a technique to make your code unreadable to humans. It is a way to protect your code from reverse engineering. There are many tools available to obfuscate your code.  In this tutorial, we will use the javascript-obfuscator package to obfuscate our code.  ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Source Code Protection","url":"/docs/extra/source-code-protection#steps","content":" Install the following packages:  npm install -D typescript @types/node ts-node tsconfig-paths eslint eslint-config-airbnb-base eslint-plugin-import jasmine ncp javascript-obfuscator tsc-alias nyc   Add the following scripts to your package.json file:  { &quot;name&quot;: &quot;your-module-name&quot;, &quot;main&quot;: &quot;dist/src/index.js&quot;, &quot;types&quot;: &quot;dist/src/index.d.ts&quot;, &quot;scripts&quot;: { &quot;obstructor:node&quot;: &quot;ncp dist obfuscated &amp;&amp; javascript-obfuscator dist --compact true --target node --output obfuscated&quot;, &quot;obstructor:browser&quot;: &quot;ncp dist obfuscated &amp;&amp; javascript-obfuscator dist --compact true --target browser --output obfuscated&quot;, } }   You can use the obstructor:node script to obfuscate your code for Node.js and the obstructor:browser script to obfuscate your code for the browser.  To compile your code into a node module, follow this tutorial. ","version":"Next","tagName":"h3"},{"title":"Relationship","type":0,"sectionRef":"#","url":"/docs/data-modelling/relationship","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#introduction","content":" Pocketto provides a way to define relationships between models. This is useful when you want to define a relationship between two models:  BelongsToHasOneHasManyBelongsToMany  ","version":"Next","tagName":"h3"},{"title":"BelongsTo​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#belongsto","content":" The BelongsTo decorator is used to define a one-to-one relationship between two models. The BelongsTo decorator takes the target model as an argument.  import { Relational, Model, BelongsTo } from 'pocketto'; @Relational export class User extends Model { profileId!: string; @BelongsTo('Profile', 'profileId', 'id') profile!: Profile; }   You may query the related model using the with method.  const user = await User.query().with('profile').find('User1'); const profile = user.profile;   Or, you may query the related model using the relationship method.  const profile = await User.relationship().profile().find('Profile1');   ","version":"Next","tagName":"h3"},{"title":"HasOne​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#hasone","content":" The HasOne decorator is used to define a one-to-one relationship between two models. The HasOne decorator takes the target model as an argument.  import { Relational, Model, HasOne } from 'pocketto'; @Relational export class Profile extends Model { @HasOne('User') user!: User; }   You may query the related model using the with method.  const profile = await Profile.query().with('user').find('Profile1'); const user = profile.user;   Or, you may query the related model using the relationship method.  const user = await Profile.relationship().user().find('User1');   ","version":"Next","tagName":"h3"},{"title":"HasMany​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#hasmany","content":" The HasMany decorator is used to define a one-to-many relationship between two models. The HasMany decorator takes the target model as an argument.  import { Relational, Model, HasMany } from 'pocketto'; @Relational export class User extends Model { @HasMany('Post') posts!: Post[]; }   You may query the related model using the with method.   const user = await User.query().with('posts').find('User1'); const posts = user.posts;   Or, you may query the related model using the relationship method.  const posts = await User.relationship().posts().find('User1');   ","version":"Next","tagName":"h3"},{"title":"BelongsToMany​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#belongstomany","content":" The BelongsToMany decorator is used to define a many-to-many relationship between two models. The BelongsToMany decorator takes the pivot model and the target model as arguments.  import { Relational, Model, BelongsToMany } from 'pocketto'; @Relational export class User extends Model { @BelongsToMany('UserPost', 'Post') posts!: Post[]; }   You may query the related model using the with method.  const user = await User.query().with('posts').find('User1'); const posts = user.posts;   Or, you may query the related model using the relationship method.  const posts = await User.relationship().posts().find('User1');  ","version":"Next","tagName":"h3"},{"title":"Vue","type":0,"sectionRef":"#","url":"/docs/installation/vue","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Vue","url":"/docs/installation/vue#installation","content":" To use Pocketto in a Vue project, you need to install the pocketto package.  npm install pocketto   You also need to install the pocketto-vue in order to use the Vue Composables.  npm install pocketto-vue   Make sure you are enabled decorators in your project. If not, you can enable it by adding the following configuration to your tsconfig.json file.  tsconfig.json { &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Using Vite​","type":1,"pageTitle":"Vue","url":"/docs/installation/vue#using-vite","content":" If you are using vite, make sure you have enable global and decorators in vite.config.ts file.  vite.config.ts import { fileURLToPath, URL } from 'node:url' import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' export default defineConfig({ plugins: [ vue(), ], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } }, define: { global: {}, }, })   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Vue","url":"/docs/installation/vue#usage","content":" You can connect to a database via the DatabaseManager.connect() function. Also, you need to set the environment to browser. You can also set the id method to timestamp which is optional. All available id method in here.  src/main.ts import { createApp } from 'vue' import App from './App.vue' import router from './router' import { DatabaseManager, p } from 'pocketto' p.setEnvironment('browser'); p.setIdMethod('timestamp'); DatabaseManager.connect('default', { dbName: 'default', }).then(() =&gt; { p.setRealtime(true); }); const app = createApp(App) app.mount('#app')  ","version":"Next","tagName":"h3"},{"title":"React Hooks","type":0,"sectionRef":"#","url":"/docs/frontend-api/pocketto-react","content":"","keywords":"","version":"Next"},{"title":"React Hooks API​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#react-hooks-api","content":" Pocketto provides a set of React hooks to interact with the Pocketto model in React.  ","version":"Next","tagName":"h2"},{"title":"useRealtimeList​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#userealtimelist","content":" By using useRealtimeList() hook, the listing will auto retrieve new model when there is new data.  import React, { useEffect } from 'react'; import { useRealtimeList } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoiceList() { const invoices = useRealtimeList(SalesInvoice); const navigate = useNavigate(); return &lt;div&gt; {invoices.map((invoice) =&gt; { return &lt;div key={invoice.id} onClick={() =&gt; navigate(`/invoices/${invoice.id}`)}&gt; &lt;h1&gt;{invoice.number}&lt;/h1&gt; &lt;/div&gt;; })} &lt;/div&gt;; }   ","version":"Next","tagName":"h3"},{"title":"useRealtimeList - Configuration​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#userealtimelist---configuration","content":" There is also options that you can pass to useRealtimeList():  animationDelay: Delay in milliseconds to wait your custom animation done. Default: 1ms.condition: A query builder condition to filter and sorting the data.onItemChange: Callback when the item is changed. After the animationDelay is done, it will emit undefined.onItemCreate: Callback when the item is created. After the animationDelay is done, it will emit undefined.onItemUpdate: Callback when the item is updated. After the animationDelay is done, it will emit undefined.  Example:  export function SalesInvoiceList() { const invoices = useRealtimeList(SalesInvoice, { animationDelay: 2000, condition: (query) =&gt; query.where('status', 'draft').orderBy('date', 'desc'), onItemChange: (item) =&gt; console.log('Item changed', item), onItemCreate: (item) =&gt; console.log('Item created', item), onItemUpdate: (item) =&gt; console.log('Item updated', item), }); }   ","version":"Next","tagName":"h3"},{"title":"useRealtime​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#userealtime","content":" By using useRealtime() hook, it will auto reflected to other similar page that have same model id.  import React, { useEffect } from 'react'; import { useParams } from 'react-router-dom'; import { useRealtime } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoiceList() { const { id } = useParams(); const [invoice, setInvoice] = useRealtime(SalesInvoice, id); return &lt;div&gt; &lt;h1&gt;{invoice?.number}&lt;/h1&gt; &lt;input value={invoice?.number} onChange={(e) =&gt; { setInvoice({ ...invoice, number: e.target.value }); }} /&gt; {/* trigger save to submit to the database */} &lt;button onClick={() =&gt; invoice.save()}&gt;Save&lt;/button&gt; &lt;/div&gt;; }  ","version":"Next","tagName":"h3"},{"title":"React","type":0,"sectionRef":"#","url":"/docs/installation/react","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"React","url":"/docs/installation/react#installation","content":" To use Pocketto in a React project, you need to install the pocketto and pocketto-react package.  npm install pocketto pocketto-react   Make sure you are enabled decorators in your project. If not, you can enable it by adding the following configuration to your tsconfig.json file.  tsconfig.json { &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Using Vite​","type":1,"pageTitle":"React","url":"/docs/installation/react#using-vite","content":" If you are using vite, make sure you have enable global and decorators in vite.config.ts file.  vite.config.ts import { defineConfig } from 'vite' import react from '@vitejs/plugin-react' export default defineConfig({ plugins: [react({ babel: { plugins: [ [&quot;@babel/plugin-proposal-decorators&quot;, { legacy: true }], [ &quot;@babel/plugin-proposal-class-properties&quot;, { loose: true }, ], ], }, })], define: { global: {}, } });   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"React","url":"/docs/installation/react#usage","content":" You can connect to a database via the DatabaseManager.connect() function. Also, you need to set the environment to browser. You can also set the id method to timestamp which is optional. All available id method in here.  src/main.tsx import { createRoot } from 'react-dom/client' import App from './App.tsx' import './index.css' import { DatabaseManager, p } from 'pocketto' p.setEnvironment('browser'); p.setIdMethod('timestamp'); DatabaseManager.connect('default', { dbName: 'default', }).then(async (localDb) =&gt; { p.setRealtime(true); }); createRoot(document.getElementById('root')).render( &lt;StrictMode&gt; &lt;App /&gt; &lt;/StrictMode&gt;, );  ","version":"Next","tagName":"h3"},{"title":"Create a Node Module","type":0,"sectionRef":"#","url":"/docs/extra/create-a-node-module","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Create a Node Module","url":"/docs/extra/create-a-node-module#introduction","content":" This is a tutorial to guide you on how to create a Node module. You can create a Node module to share your code with others or to reuse your code in different projects. Such as Node.js, Bun.js or React.js.  Assumption This tutorial is assumed that you source code are all in src folder, an you have a index.ts file in the root directory of your project. If you have a different structure, you can modify the tsconfig.json file to match your project structure.  ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Create a Node Module","url":"/docs/extra/create-a-node-module#steps","content":" Install the following packages:  npm install -D typescript @types/node ts-node tsconfig-paths eslint eslint-config-airbnb-base eslint-plugin-import jasmine ncp javascript-obfuscator tsc-alias nyc   Add the following scripts to your package.json file:  { &quot;name&quot;: &quot;your-module-name&quot;, &quot;main&quot;: &quot;dist/src/index.js&quot;, &quot;types&quot;: &quot;dist/src/index.d.ts&quot;, &quot;scripts&quot;: { &quot;compile:type&quot;: &quot;tsc --project tsconfig-node.json --declaration --declarationDir dist --emitDeclarationOnly &amp;&amp; tsc-alias -p tsconfig-types.json&quot;, &quot;compile:browser&quot;: &quot;tsc --project tsconfig-browser.json &amp;&amp; tsc-alias -p tsconfig-browser.json &amp;&amp; rm -Rf dist/node/mocks &amp;&amp; rm -Rf dist/node/spec &amp;&amp; rm -Rf dist/node/debug&quot;, &quot;compile:node&quot;: &quot;tsc --project tsconfig-node.json &amp;&amp; tsc-alias -p tsconfig.json &amp;&amp; rm -Rf dist/browser/mocks &amp;&amp; rm -Rf dist/browser/spec &amp;&amp; rm -Rf dist/browser/debug&quot;, &quot;build&quot;: &quot;npm run compile:type &amp;&amp; npm run compile:browser &amp;&amp; npm run compile:node &amp;&amp; npm pack&quot;, } }   Create 3 files in the root directory of your project:  tsconfig-type.json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;src/*&quot;: [ &quot;./src/*&quot; ] }, &quot;lib&quot;: [ &quot;ES2021&quot; ], &quot;outDir&quot;: &quot;./dist&quot;, &quot;sourceMap&quot;: true, &quot;target&quot;: &quot;ES2015&quot;, &quot;module&quot;: &quot;CommonJS&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;esModuleInterop&quot;: true, &quot;declaration&quot;: false, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true }, &quot;include&quot;: [ &quot;src/&quot;, &quot;index.ts&quot;, &quot;**/*.tgz&quot;, &quot;**/*.patch&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/__tests__/*&quot;, &quot;dist&quot;, &quot;spec/&quot;, &quot;mocks/&quot;, ] }   tsconfig-node.json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;src/*&quot;: [ &quot;./src/*&quot; ] }, &quot;lib&quot;: [ &quot;ES2021&quot; ], &quot;outDir&quot;: &quot;./dist/node&quot;, &quot;sourceMap&quot;: true, &quot;target&quot;: &quot;ES2015&quot;, &quot;module&quot;: &quot;CommonJS&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;esModuleInterop&quot;: true, &quot;declaration&quot;: false, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true }, &quot;include&quot;: [ &quot;src/&quot;, &quot;index.ts&quot;, &quot;**/*.tgz&quot;, &quot;**/*.patch&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/__tests__/*&quot;, &quot;dist&quot;, &quot;mocks/&quot;, &quot;spec/&quot; ] }   tsconfig-browser.json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;src/*&quot;: [ &quot;./src/*&quot; ] }, &quot;lib&quot;: [ &quot;ES2021&quot; ], &quot;outDir&quot;: &quot;./dist/browser&quot;, &quot;sourceMap&quot;: true, &quot;target&quot;: &quot;ES2015&quot;, &quot;module&quot;: &quot;ES2015&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;esModuleInterop&quot;: true, &quot;declaration&quot;: false, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true }, &quot;include&quot;: [ &quot;src/&quot;, &quot;index.ts&quot;, &quot;**/*.tgz&quot;, &quot;**/*.patch&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/__tests__/*&quot;, &quot;dist&quot;, &quot;spec/&quot;, &quot;mocks/&quot;, ] }   After complete the above steps, you can run the following command to build your module:  npm run build   Then you will get a &lt;your-module-name&gt;.tgz file in the root directory of your project. You can publish this file to npm, or share it with others.  Then run the following command in your destination project to install your module:  npm install &lt;your-module-name&gt;.tgz  ","version":"Next","tagName":"h3"},{"title":"Vue Composables","type":0,"sectionRef":"#","url":"/docs/frontend-api/pocketto-vue","content":"","keywords":"","version":"Next"},{"title":"Vue Composables API​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#vue-composables-api","content":" Pocketto provides a set of Vue composables to interact with the Pocketto model in Vue.  ","version":"Next","tagName":"h2"},{"title":"useRealtimeList​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#userealtimelist","content":" By using useRealtimeList() composable, the listing will auto retrieve new model when there is new data.  {/* &lt;script setup lang=&quot;ts&quot;&gt; */} import { SalesInvoice } from '@/models/SalesInvoice.p'; import { ref } from 'vue'; import { useRouter } from 'vue-router'; import { useRealtimeList } from 'pocketto-vue'; const changedItem = ref&lt;SalesInvoice&gt;(); const salesInvoices = useRealtimeList(SalesInvoice, { animationDelay: 3000, itemChange: (item) =&gt; { changedItem.value = item; }, }); const router = useRouter(); function navigateToInvoice(invoice: SalesInvoice) { router.push(`/invoices/${invoice.id}`); } {/* &lt;/script&gt; */} &lt;template&gt; &lt;div&gt; &lt;div v-for=&quot;invoice in salesInvoices&quot; :key=&quot;invoice.id&quot; @click=&quot;navigateToInvoice(invoice)&quot;&gt; &lt;h1&gt;{{ invoice.number }}&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;   ","version":"Next","tagName":"h3"},{"title":"useRealtimeList - Configuration​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#userealtimelist---configuration","content":" There is also options that you can pass to useRealtimeList():  animationDelay: Delay in milliseconds to wait your custom animation done. Default: 1ms.condition: A query builder condition to filter and sorting the data.onItemChange: Callback when the item is changed. After the animationDelay is done, it will emit undefined.onItemCreate: Callback when the item is created. After the animationDelay is done, it will emit undefined.onItemUpdate: Callback when the item is updated. After the animationDelay is done, it will emit undefined.  Example:  {/* &lt;script setup lang=&quot;ts&quot;&gt; */} import { SalesInvoice } from '@/models/SalesInvoice.p'; import { ref } from 'vue'; import { useRealtimeList } from 'pocketto-vue'; const changedItem = ref&lt;SalesInvoice&gt;(); const salesInvoices = useRealtimeList(SalesInvoice, { animationDelay: 3000, condition: (query) =&gt; query.where('status', 'draft').orderBy('date', 'desc'), itemChange: (item) =&gt; { changedItem.value = item; }, }); {/* &lt;/script&gt; */}   ","version":"Next","tagName":"h3"},{"title":"useRealtime​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#userealtime","content":" By using useRealtime() hook, it will auto reflected to other similar page that have same model id.  {/* &lt;script setup lang=&quot;ts&quot;&gt; */} import { SalesInvoice } from '@/models/SalesInvoice.p'; import { ref } from 'vue'; import { useRealtime } from 'pocketto-vue'; const route = useRoute(); const router = useRouter(); const id = route.params.id; const invoice = useRealtime(SalesInvoice, id); watch(() =&gt; route.params.id, (newId, oldId) =&gt; { if (newId !== oldId) { invoice = useRealtime(SalesInvoice, newId as string); } }); {/* &lt;/script&gt; */} &lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ invoice.number }}&lt;/h1&gt; &lt;input v-model=&quot;invoice.number&quot; /&gt; {/* trigger save to submit to the database */} &lt;button @click=&quot;invoice.save()&quot;&gt;Save&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;  ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Highlights​","type":1,"pageTitle":"Introduction","url":"/docs/intro#highlights","content":" Offline First Architecture: You can use Pocketto without internet connection. Even in web application.Sync: Sync your data across different platforms.Run with different javascript environment: Pocketto can run in different javascript environment like Node.js, Browser, React Native, so you don't need to rewrite your business logic in different platform.Encrypted: Pocketto allow you to encrypts your data and store it locally.Open Source: Pocketto is open source so everybody can use it and inspect the code to prevent any security issues.  ","version":"Next","tagName":"h3"},{"title":"Getting Started​","type":1,"pageTitle":"Introduction","url":"/docs/intro#getting-started","content":" To get started, click here to proceed.  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"Introduction","url":"/docs/intro#examples","content":" You can download and setup the example project from below: ample Projects  React Example React Native Example Vue Example  ","version":"Next","tagName":"h3"},{"title":"React Native","type":0,"sectionRef":"#","url":"/docs/installation/react-native","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"React Native","url":"/docs/installation/react-native#installation","content":" To use Pocketto in a React project, you need to install the pocketto and pocketto-react package.  npm install pocketto pocketto-react   Also, to install native dependencies in order to let pocketto work properly, you need to install the following packages.  npm install -D @babel/plugin-proposal-decorators @babel/plugin-transform-class-static-block babel-plugin-module-resolver babel-plugin-transform-decorators-legacy rn-nodeify npm install @tradle/react-native-http assert buffer https-browserify path-browserify process react-native-crypto react-native-get-random-values react-native-level-fs react-native-os react-native-randombytes react-native-sqlite-2 readable-stream stream-browserify url base-64 pouchdb-adapter-react-native-sqlite@3.0.1   Add postinstall script to your package.json file.  package.json { &quot;scripts&quot;: { &quot;postinstall&quot;: &quot;rn-nodeify --install fs,process,url,assert,crypto,http,https,os,buffer,stream,path --hack&quot; } }   Add shim.js file to the root of your project.  shim.js import { shim } from 'react-native-quick-base64'; shim(); if (typeof __dirname === 'undefined') global.__dirname = '/'; if (typeof __filename === 'undefined') global.__filename = ''; if (typeof process === 'undefined') { global.process = require('process'); } else { const bProcess = require('process'); for (var p in bProcess) { if (!(p in process)) { process[p] = bProcess[p]; } } } process.browser = false; process.nextTick = setImmediate; if (typeof Buffer === 'undefined') global.Buffer = require('buffer').Buffer; const isDev = typeof __DEV__ === 'boolean' &amp;&amp; __DEV__; process.env['NODE_ENV'] = isDev ? 'development' : 'production'; if (typeof localStorage !== 'undefined') { localStorage.debug = isDev ? '*' : ''; } // If using the crypto shim, uncomment the following line to ensure // crypto is loaded first, so it can populate global.crypto // require('crypto')   Make sure you are enabled decorators in your project. If not, you can enable it by adding the following configuration to your tsconfig.json file.  tsconfig.json { &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"iOS Configuration​","type":1,"pageTitle":"React Native","url":"/docs/installation/react-native#ios-configuration","content":" For iOS, make sure you are running pod install after installing the packages for native dependencies.  npx pod-install   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"React Native","url":"/docs/installation/react-native#usage","content":" You can connect to a database via the DatabaseManager.connect() function. Also, you need to set the environment to react-native. You can also set the id method to timestamp which is optional. All available id method in here.  You also need to manually install the SQLite adapter for PouchDB.  index.js import { AppRegistry } from 'react-native'; import App from './App'; import 'react-native-get-random-values'; import PouchDB from 'pouchdb'; import SQLiteAdapterFactory from 'pouchdb-adapter-react-native-sqlite'; import SQLite from 'react-native-sqlite-2'; import { DatabaseManager, p } from &quot;pocketto&quot;; const SQLiteAdapter = SQLiteAdapterFactory(SQLite); PouchDB.plugin(SQLiteAdapter); p.setEnvironment(&quot;react-native&quot;); p.setIdMethod('timestamp'); DatabaseManager.connect('default', { adapter: 'react-native-sqlite', dbName: 'default' }).then((localDb) =&gt; { const remoteHost = Platform.OS === 'android' ? 'http://192.168.68.107:5984' : 'http://localhost:5984'; p.setRealtime(true); }); AppRegistry.registerComponent(appName, () =&gt; App);  ","version":"Next","tagName":"h3"},{"title":"React Native Hooks","type":0,"sectionRef":"#","url":"/docs/frontend-api/pocketto-react-native","content":"","keywords":"","version":"Next"},{"title":"React Hooks API​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#react-hooks-api","content":" Pocketto provides a set of React hooks to interact with the Pocketto model in React Native.  ","version":"Next","tagName":"h2"},{"title":"useRealtimeList​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#userealtimelist","content":" By using useRealtimeList() hook, the listing will auto retrieve new model when there is new data.  import React, { useEffect } from 'react'; import { Pressable, Text, View } from &quot;react-native&quot;; import { useRoute } from &quot;@react-navigation/native&quot;; import { NativeStackScreenProps } from &quot;@react-navigation/native-stack&quot;; import { useRealtimeList } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoiceList({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const invoices = useRealtimeList(SalesInvoice); return &lt;View&gt; {invoices.map((invoice) =&gt; { const onPress = () =&gt; { navigation.navigate('SalesInvoicePage', { id: invoice.id }); }; return &lt;Pressable key={invoice.id} onPress={onPress}&gt; &lt;Text&gt;{invoice.number}&lt;/Text&gt; &lt;/Pressable&gt;; })} &lt;/View&gt;; }   ","version":"Next","tagName":"h3"},{"title":"useRealtimeList - Configuration​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#userealtimelist---configuration","content":" There is also options that you can pass to useRealtimeList():  animationDelay: Delay in milliseconds to wait your custom animation done. Default: 1ms.condition: A query builder condition to filter and sorting the data.onItemChange: Callback when the item is changed. After the animationDelay is done, it will emit undefined.onItemCreate: Callback when the item is created. After the animationDelay is done, it will emit undefined.onItemUpdate: Callback when the item is updated. After the animationDelay is done, it will emit undefined.  Example:  export function SalesInvoiceList({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const invoices = useRealtimeList(SalesInvoice, { animationDelay: 2000, condition: (query) =&gt; query.where('status', 'draft').orderBy('date', 'desc'), onItemChange: (item) =&gt; console.log('Item changed', item), onItemCreate: (item) =&gt; console.log('Item created', item), onItemUpdate: (item) =&gt; console.log('Item updated', item), }); }   ","version":"Next","tagName":"h3"},{"title":"useRealtime​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#userealtime","content":" By using useRealtime() hook, it will auto reflected the data that have same model id in other opened screen.  import React, { useEffect } from 'react'; import { Pressable, Text, View } from &quot;react-native&quot;; import { useRoute } from &quot;@react-navigation/native&quot;; import { NativeStackScreenProps } from &quot;@react-navigation/native-stack&quot;; import { useRealtime } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoicePage({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const route = useRoute(); const { id } = route.params; const [invoice, setInvoice] = useRealtime(SalesInvoice, id); return &lt;View&gt; &lt;Text&gt;{invoice?.number}&lt;/Text&gt; &lt;TextInput value={invoice?.number} onTextChange={(value) =&gt; { setInvoice({ ...invoice, number: value }); }} /&gt; {/* trigger save to submit to the database */} &lt;Pressable onPress={() =&gt; invoice.save()}&gt;Save&lt;/Pressable&gt; &lt;/View&gt;; }   You can use the useEffect to listen if the model._meta._rev is changed, so you can show some message to user that the data is updated.  export function SalesInvoicePage({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const [invoice, setInvoice] = useRealtime(SalesInvoice, id); const [rev, setRev] = useState(''); useEffect(() =&gt; { if (invoice._meta._rev !== rev &amp;&amp; rev &amp;&amp; invoice._meta._rev) { console.log('Data updated'); } else { setRev(invoice._meta._rev); } }, [invoice._meta._rev, rev]); }  ","version":"Next","tagName":"h3"}],"options":{"languages":["en"],"id":"default"}}