{"searchDocs":[{"title":"First Blog Post","type":0,"sectionRef":"#","url":"/blog/first-blog-post","content":"Lorem ipsum dolor sit amet... ...consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"Long Blog Post","type":0,"sectionRef":"#","url":"/blog/long-blog-post","content":"This is the summary of a very long blog post, Use a &lt;!-- truncate --&gt; comment to limit blog post size in the list view. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque elementum dignissim ultricies. Fusce rhoncus ipsum tempor eros aliquam consequat. Lorem ipsum dolor sit amet","keywords":"","version":null},{"title":"MDX Blog Post","type":0,"sectionRef":"#","url":"/blog/mdx-blog-post","content":"Blog posts support Docusaurus Markdown features, such as MDX. tip Use the power of React to create interactive blog posts. For example, use JSX to create an interactive button: &lt;button onClick={() =&gt; alert('button clicked!')}&gt;Click me!&lt;/button&gt; Click me!","keywords":"","version":null},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Here are a few tips you might find useful. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":"","version":null},{"title":"Data Syncing","type":0,"sectionRef":"#","url":"/docs/data-management/data-syncing","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Syncing","url":"/docs/data-management/data-syncing#introduction","content":" The syncDatabases method is used to synchronize the local database with the remote database. This method will fetch the data from the remote database and update the local database.  Assumption This tutorial is assumed that you have already connected to a local database via this tutorial.  import { DatabaseManager, syncDatabases } from 'pocketto'; async function syncWithRemote() { const db = DatabaseManager.get('my-database'); const remoteDb = await DatabaseManager.connect('http://localhost:5984', { dbName: 'remote-database', adapter: 'http', auth: { username: 'admin', password: 'password' }, }); syncDatabases(remoteDb.config.dbName, localDb.config.dbName); await new Promise((resolve) =&gt; { remoteDb.sync(localDb, { live: false, retry: true, continuous: false, }).on(&quot;complete&quot;, () =&gt; { console.log(&quot;Your local database has been fully synced with your remote database!&quot;); resolve(true); }); }); }  ","version":"Next","tagName":"h3"},{"title":"Data Sharding","type":0,"sectionRef":"#","url":"/docs/data-management/data-sharding","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Sharding","url":"/docs/data-management/data-sharding#introduction","content":" Data sharding is a method of partitioning data across multiple servers. It is a technique used to distribute data across multiple servers to improve the performance and scalability of the database. Sharding is a common technique used in distributed databases to improve the performance of the database by distributing the data across multiple servers.  To sharding the model data into different databases, you can declare shardingMode in your model.  Please also setup for setMainDatabaseName before using the sharding mode. The first argument is the database name, and the second argument is the database adapter.  Available adapters:  memory: An adapter to store data in memory.idb: An adapter to store data in IndexedDB.leveldb: An adapter to store data in LevelDB.websql: An adapter to store data in WebSQL.http: An adapter to store data in a remote server.  import { Model, setMainDatabaseName, ShardingMode } from 'pocketto'; setMainDatabaseName('master', 'idb'); class SalesInvoice extends Model { static dbName = 'master'; static collectionName = 'SalesInvoices'; static shardingMode = ShardingMode.TimeSeries; invoiceNumber!: string; customerName!: string; remarks?: string; @HasMany('SalesInvoiceItem') items?: SalesInvoiceItem[]; get totalAmount() { return this.items?.reduce((total, item) =&gt; total + item.amount, 0) ?? 0; } }   ","version":"Next","tagName":"h3"},{"title":"Usage - Time Series​","type":1,"pageTitle":"Data Sharding","url":"/docs/data-management/data-sharding#usage---time-series","content":" To use the time series sharding mode, you can set the shardingMode to ShardingMode.TimeSeries.  The database will automatically create a new database for each month when you want to create a instance within the period. The database name will be in the format of master-2021-01, master-2021-02, master-2021-03, and so on.  You can pass in period as the second argument when creating a new instance.  const invoice = await Invoice.create({ invoiceNumber: 'INV-2021-01-001', customerName: 'John Doe', remarks: 'This is a test invoice', items: [ { description: 'Item 1', quantity: 1, price: 100 }, { description: 'Item 2', quantity: 2, price: 200 }, ], }, '2021-01');   You can manage the data by normal query methods.  const savedInvoice = await Invoice.find(invoice.id); savedInvoice.remarks = 'This is a test invoice updated'; await savedInvoice.save();  ","version":"Next","tagName":"h3"},{"title":"Database Manager","type":0,"sectionRef":"#","url":"/docs/data-management/database-manager","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#introduction","content":" The DatabaseManager is a class that provides a set of methods to interact with the database. It is responsible for creating, updating, and deleting records in the database.  import { DatabaseManager } from 'pocketto'; DatabaseManager.connect('default', { encryption: false, silentConnect: false, dbName: 'default', adapter: 'memory', auth: { username: 'admin', password: 'password' }, });   ","version":"Next","tagName":"h3"},{"title":"Slient Connect​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#slient-connect","content":" By default, when connected to the database, it will show a message in the console.    You can disable this message by setting the silentConnect option to true.  DatabaseManager.connect('default', { silentConnect: true, });     ","version":"Next","tagName":"h3"},{"title":"Database Name​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#database-name","content":" You can specify the name of the database by setting the dbName option.  DatabaseManager.connect('default', { dbName: 'my-database', });   Then, you can use DatabaseManager.get() to get the database instance.  const db = DatabaseManager.get('my-database');   ","version":"Next","tagName":"h3"},{"title":"Authentication​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#authentication","content":" You can specify the username and password to authenticate with the remote server.  DatabaseManager.connect('http://localhost:5984', { dbName: 'remote-database', adapter: 'http', auth: { username: 'admin', password: 'password' }, });   ","version":"Next","tagName":"h3"},{"title":"Adapters​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#adapters","content":" The DatabaseManager uses adapters to interact with the database including:  memory: An adapter to store data in memory.idb: An adapter to store data in IndexedDB.leveldb: An adapter to store data in LevelDB.websql: An adapter to store data in WebSQL.http: An adapter to store data in a remote server.  ","version":"Next","tagName":"h3"},{"title":"React Native Adapters​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#react-native-adapters","content":" react-native-sqlite: An adapter to store data in SQLite database in React Native.  ","version":"Next","tagName":"h3"},{"title":"Encryption​","type":1,"pageTitle":"Database Manager","url":"/docs/data-management/database-manager#encryption","content":" For more information on how to encrypt data, see Data Encryption. ","version":"Next","tagName":"h3"},{"title":"ID Generation","type":0,"sectionRef":"#","url":"/docs/data-modelling/id","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"ID Generation","url":"/docs/data-modelling/id#introduction","content":" Pocketto provides a way to generate unique ids for your data. You can set the id method to generate unique ids.  ","version":"Next","tagName":"h3"},{"title":"Set id Method​","type":1,"pageTitle":"ID Generation","url":"/docs/data-modelling/id#set-id-method","content":" import { p } from 'pocketto'; p.setIdMethod('uuid');   Available id methods:  uuid - Generates a unique id via uuidv7, which is sort by time.shortid - Generates a unique id using the shortid package.timestamp - Generates a unique id using the current timestamp. Format: YYYYMMDDHHmmssSSSincrement - Generates a unique id by incrementing the previous id. It is useful for testing purposes.safe-increment - Generates a unique id by incrementing the previous id with timestamp. Format: &lt;RUNNING_NUMBER&gt;-YYYYMMDDHHmmssSSScustom - Generates a unique id using the custom function you provide. ","version":"Next","tagName":"h3"},{"title":"Data Conflict","type":0,"sectionRef":"#","url":"/docs/data-management/data-conflict","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#introduction","content":" Under the hoods, Pocketto are rely on the field document._meta._rev to trace for the revision of the document.  When a document is updated, the revision number is incremented. This allows Pocketto to detect conflicts when two clients try to update the same document at the same time.  When a conflict occurs, it will return a 409 (conflict) error to the client. The client can then resolve the conflict by fetching the latest version of the document, merging the changes, and then trying to update the document again.  ","version":"Next","tagName":"h3"},{"title":"Two Types of Conflicts​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#two-types-of-conflicts","content":" There are two types of conflicts that can occur in the database:  Immediate conflictsEventual conflicts  ","version":"Next","tagName":"h3"},{"title":"Immediate Conflicts​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#immediate-conflicts","content":" Immediate conflicts can occur with any API that using the same ref to store. They manifest as a 409 (conflict) error:  import { SalesInvoice } from 'src/models/SalesInvoice.p'; // 1. Client A create a document call `A` const invoiceA = new SalesInvoice(); invoiceA.id = '1'; invoiceA.number = 'INV-001'; await invoiceA.save(); console.log(invoice._meta._rev); // 1-x // 2. Client B create a document call `A` at the same time try { const invoiceB = new SalesInvoice(); invoiceA.id = '1'; invoiceA.number = 'INV-001'; await invoiceA.save(); } catch (error) { if (err.name !== 'conflict') return; console.log('Conflict happen!:', error); // 409 (conflict) }   warning Normally, _rev look more like 2-c1592ce7b31cc26e91d2f2029c57e621, i.e. a digit followed by a very long hash. In these examples, x and y are used in place of the hash, for simplicity’s sake.  ","version":"Next","tagName":"h3"},{"title":"Eventual Conflicts​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#eventual-conflicts","content":" Eventual conflicts can occur when both clients are fully offline and then come back online. They manifest as a 409 (conflict) error:  const invoiceA = await SalesInvoice.find('1');   Imagine the return are the below:  SalesInvoice { id: &quot;1&quot;, _meta: { _rev: &quot;10-x&quot;, _before_update: {}, _dirty: {} } number: &quot;INV-001&quot;, }   In another client that also fetch the same document, and just connect to the internet and update the document:  const invoiceB = await SalesInvoice.find('1');   SalesInvoice { id: &quot;1&quot;, _meta: { _rev: &quot;10-y&quot;, _before_update: {}, _dirty: {} } number: &quot;INV-002&quot;, }   When the first client try to update the document:  invoiceA.number = 'INV-003'; await invoiceA.save();   The server will return a 409 (conflict) error:  { name: 'conflict', message: 'Document update conflict', status: 409, error: true, reason: 'Document update conflict', revision: '10-y' }   ","version":"Next","tagName":"h3"},{"title":"Solution​","type":1,"pageTitle":"Data Conflict","url":"/docs/data-management/data-conflict#solution","content":" To handle the conflict, you can do the below step to ensure the document is updated correctly:  Get the latest document via find method.Update the field you wish to replace.Save the document again.  let invoiceA = await SalesInvoice.find('1'); invoiceA.number = 'INV-003'; try { await invoiceA.save(); } catch (error) { if (err.name !== 'conflict') return; // Get the latest document invoiceA = await SalesInvoice.find('1'); // Merge the changes invoiceA.number = 'INV-003'; // Save the document again await invoiceA.save(); }  ","version":"Next","tagName":"h3"},{"title":"Data Encryption","type":0,"sectionRef":"#","url":"/docs/data-management/encryption","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Data Encryption","url":"/docs/data-management/encryption#introduction","content":" The encrypt method is used to encrypt the data before storing it in the database. The framework uses the libsodium-wrappers library to encrypt the data.  import { DatabaseManager } from 'pocketto'; DatabaseManager.connect('default', { encryption: true, encryptionPassword: '12345', silentConnect: false, dbName: 'default', adapter: 'idb', });   All the data will be encrypted into payload field, so people will not be able to read the data directly from the database.   ","version":"Next","tagName":"h3"},{"title":"Model","type":0,"sectionRef":"#","url":"/docs/data-modelling/model","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#introduction","content":" Pocketto Model allow you to create a model for your data. It is a simple and easy way to create a model for your data.  You can share the model in different platforms, so all the platforms can use the same model with same application logic.  ","version":"Next","tagName":"h3"},{"title":"Define a Model​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#define-a-model","content":" To define a model, you need to create a class that extends the Model class. The Model class is a base class that provides the basic functionality for a model.  In the following example, we define a SalesInvoiceItem model and a SalesInvoice model.  import { Model } from 'pocketto'; @Relational export class SalesInvoiceItem extends Model { static dbName = 'my-database'; static collectionName = 'SalesInvoiceItems'; description!: string; quantity!: number; unitPrice!: number; get amount() { return this.quantity * this.unitPrice; } } @Relational export class SalesInvoice extends Model { static dbName = 'my-database'; static collectionName = 'SalesInvoices'; invoiceNumber!: string; customerName!: string; remarks?: string; @HasMany('SalesInvoiceItem') items?: SalesInvoiceItem[]; get totalAmount() { return this.items?.reduce((total, item) =&gt; total + item.amount, 0) ?? 0; } }   The decorator @Relational is used to define the model as a relational model. The @HasMany decorator is used to define a one-to-many relationship between the SalesInvoice model and the SalesInvoiceItem model.  ","version":"Next","tagName":"h3"},{"title":"Create an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#create-an-instance","content":" To create an instance of a model, you can use the new keyword.  const invoice = new SalesInvoice(); invoice.invoiceNumber = 'INV-001'; invoice.customerName = 'John Doe'; invoice.remarks = 'This is a sample invoice.'; invoice.items = [ { description: 'Item 1', quantity: 2, unitPrice: 100 }, { description: 'Item 2', quantity: 3, unitPrice: 150 }, ]; // or const invoice = new SalesInvoice({ invoiceNumber = 'INV-001', customerName = 'John Doe', remarks = 'This is a sample invoice.'; items = [ { description: 'Item 1', quantity: 2, unitPrice: 100 }, { description: 'Item 2', quantity: 3, unitPrice: 150 }, ], });   ","version":"Next","tagName":"h3"},{"title":"Save an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#save-an-instance","content":" To save an instance of a model, you can use the save method.  await invoice.save();   ","version":"Next","tagName":"h3"},{"title":"Find an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#find-an-instance","content":" To find an instance of a model, you can use the find method.  const invoice = await SalesInvoice.find('INV-001');   ","version":"Next","tagName":"h3"},{"title":"Find all Instances​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#find-all-instances","content":" To get all instances of a model, you can use the all method.  const invoice = await SalesInvoice.all();   ","version":"Next","tagName":"h3"},{"title":"Update an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#update-an-instance","content":" To update an instance of a model, you can use the update method.  invoice.update({ remarks: 'This is an updated invoice.', });   ","version":"Next","tagName":"h3"},{"title":"Delete an Instance​","type":1,"pageTitle":"Model","url":"/docs/data-modelling/model#delete-an-instance","content":" To delete an instance of a model, you can use the delete method.  await invoice.delete(true);  ","version":"Next","tagName":"h3"},{"title":"Database Client Tools","type":0,"sectionRef":"#","url":"/docs/database-client-tools","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Database Client Tools","url":"/docs/database-client-tools#introduction","content":" Introduce Poker, a real-time database client tool for Pocketto built with React.  By using this, you may monitor your database in real-time, execute queries, and manage your data with ease.    ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Database Client Tools","url":"/docs/database-client-tools#installation","content":" You can clone and run the Poker tool locally.  git clone git@github.com:pockettojs/pocketto-docs.git cd poker npm install npm run start  ","version":"Next","tagName":"h3"},{"title":"Environment Setup","type":0,"sectionRef":"#","url":"/docs/environment-setup","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Environment Setup","url":"/docs/environment-setup#introduction","content":" Before you start using Pocketto, you need to set up your environment. This guide will help you set up your environment to start using Pocketto.  ","version":"Next","tagName":"h3"},{"title":"Prerequisites​","type":1,"pageTitle":"Environment Setup","url":"/docs/environment-setup#prerequisites","content":" Before you start setting up your environment, make sure you have the following installed:  CouchDB, a real-time NoSQL database that allows you to store your data in local as well as in the cloud.Node.js, version 14 or above is recommended.python. In order to build native modules of npm modules: leveldown, sqlite3, etc.node-gyp  ","version":"Next","tagName":"h3"},{"title":"Platform Installation​","type":1,"pageTitle":"Environment Setup","url":"/docs/environment-setup#platform-installation","content":" Depending on your project platform, you can pick one of the following installation methods:  Frontend  ReactReact NativeVueSvelte  Backend  Bun  ","version":"Next","tagName":"h3"},{"title":"Debug for npm/yarn install​","type":1,"pageTitle":"Environment Setup","url":"/docs/environment-setup#debug-for-npmyarn-install","content":" If you found the issue for the python dependencies problem ModuleNotFoundError: No module named 'distutils', you can try the following  Install python 3.8 or aboveInstall the distutils package by running the following command:  python -m venv venv source venv/bin/activate pip install setuptools   Install node-gyp globally by running the following command:  npm install -g node-gyp   You can now proceed with the installation of Pocketto in your project. ","version":"Next","tagName":"h3"},{"title":"Query Builder","type":0,"sectionRef":"#","url":"/docs/data-modelling/query-builder","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#introduction","content":" Pocketto Query Builder allows you to build queries for your data. It is a simple and easy way to build queries for your data.  ","version":"Next","tagName":"h3"},{"title":"Build a Query​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#build-a-query","content":" You can utilize Model.query() to build a query. The query() method returns a new instance of the QueryBuilder class.  In the following example, we build a query to get all sales invoices with a total amount greater than 1000.  import { SalesInvoice } from './models'; const invoices = await SalesInvoice.query() .where('totalAmount', '&gt;', 1000) .get();   The where() method is used to add a condition to the query. The first argument is the field name, the second argument is the operator, and the third argument is the value.  If you want to only get the first result, you can use the first() method.  const invoice = await SalesInvoice.query() .where('invoiceNumber', '=', 'INV-001') .first();   ","version":"Next","tagName":"h3"},{"title":"Complex Queries - Chaining​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#complex-queries---chaining","content":" You can build complex queries by chaining multiple where and orWhere.  In the following example, we build a query to get all sales invoices with a total amount greater than 1000 or where the customer name is John Doe.  const invoices = await SalesInvoice.query() .where('totalAmount', '&gt;', 1000) .orWhere('customerName', '=', 'John Doe') .get();   ","version":"Next","tagName":"h3"},{"title":"Complex Queries - Callback​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#complex-queries---callback","content":" You can also able to pass in a callback function to build complex queries.  The callback function receives a QueryBuilder instance as an argument.  import { QueryBuilder } from 'pocketto'; const invoices = await SalesInvoice.query() .where((query: QueryBuilder&lt;SalesInvoice&gt;) =&gt; { query.where('totalAmount', '&gt;', 1000) .orWhere('customerName', '=', 'John Doe'); }) .get();   ","version":"Next","tagName":"h3"},{"title":"Complex Queries - Object​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#complex-queries---object","content":" Or, pass a object to build complex queries.  const invoices = await SalesInvoice.query() .where({ totalAmount: ['&gt;', 1000], customerName: ['=', 'John Doe'], }) .get();   ","version":"Next","tagName":"h3"},{"title":"Sorting​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#sorting","content":" You can sort the results by using the orderBy() method.  const invoices = await SalesInvoice.query() .orderBy('invoiceNumber', 'desc') .get();   The first argument is the field name, and the second argument is the direction (asc or desc).  ","version":"Next","tagName":"h3"},{"title":"Pagination​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#pagination","content":" You can paginate the results by using the paginate() method.  const invoices = await SalesInvoice.query() .paginate(1, 10);   The first argument is the page number, and the second argument is the number of items per page.  ","version":"Next","tagName":"h3"},{"title":"Counting​","type":1,"pageTitle":"Query Builder","url":"/docs/data-modelling/query-builder#counting","content":" You can count the results by using the count() method.  const count = await SalesInvoice.query() .where('totalAmount', '&gt;', 1000) .count();  ","version":"Next","tagName":"h3"},{"title":"Source Code Protection","type":0,"sectionRef":"#","url":"/docs/extra/source-code-protection","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Source Code Protection","url":"/docs/extra/source-code-protection#introduction","content":" This is a tutorial to guide you how to protect your source code to prevent reverse engineering.  Assumption This tutorial is assumed that you source code are all in src folder, an you have a index.ts file in the root directory of your project. If you have a different structure, you can modify the tsconfig.json file to match your project structure.  ","version":"Next","tagName":"h3"},{"title":"Obfuscation​","type":1,"pageTitle":"Source Code Protection","url":"/docs/extra/source-code-protection#obfuscation","content":" Obfuscation is a technique to make your code unreadable to humans. It is a way to protect your code from reverse engineering. There are many tools available to obfuscate your code.  In this tutorial, we will use the javascript-obfuscator package to obfuscate our code.  ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Source Code Protection","url":"/docs/extra/source-code-protection#steps","content":" Install the following packages:  npm install -D typescript @types/node ts-node tsconfig-paths eslint eslint-config-airbnb-base eslint-plugin-import jasmine ncp javascript-obfuscator tsc-alias nyc   Add the following scripts to your package.json file:  { &quot;name&quot;: &quot;your-module-name&quot;, &quot;main&quot;: &quot;dist/src/index.js&quot;, &quot;types&quot;: &quot;dist/src/index.d.ts&quot;, &quot;scripts&quot;: { &quot;obstructor:node&quot;: &quot;ncp dist obfuscated &amp;&amp; javascript-obfuscator dist --compact true --target node --output obfuscated&quot;, &quot;obstructor:browser&quot;: &quot;ncp dist obfuscated &amp;&amp; javascript-obfuscator dist --compact true --target browser --output obfuscated&quot;, } }   You can use the obstructor:node script to obfuscate your code for Node.js and the obstructor:browser script to obfuscate your code for the browser.  To compile your code into a node module, follow this tutorial. ","version":"Next","tagName":"h3"},{"title":"Relationship","type":0,"sectionRef":"#","url":"/docs/data-modelling/relationship","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#introduction","content":" Pocketto provides a way to define relationships between models. This is useful when you want to define a relationship between two models:  BelongsToHasOneHasManyBelongsToMany  ","version":"Next","tagName":"h3"},{"title":"BelongsTo​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#belongsto","content":" The BelongsTo decorator is used to define a one-to-one relationship between two models. The BelongsTo decorator takes the target model as an argument.  import { Relational, Model, BelongsTo } from 'pocketto'; @Relational export class User extends Model { profileId!: string; @BelongsTo('Profile', 'profileId', 'id') profile!: Profile; }   You may query the related model using the with method.  const user = await User.query().with('profile').find('User1'); const profile = user.profile;   Or, you may query the related model using the relationship method.  const profile = await User.relationship().profile().find('Profile1');   ","version":"Next","tagName":"h3"},{"title":"HasOne​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#hasone","content":" The HasOne decorator is used to define a one-to-one relationship between two models. The HasOne decorator takes the target model as an argument.  import { Relational, Model, HasOne } from 'pocketto'; @Relational export class Profile extends Model { @HasOne('User') user!: User; }   You may query the related model using the with method.  const profile = await Profile.query().with('user').find('Profile1'); const user = profile.user;   Or, you may query the related model using the relationship method.  const user = await Profile.relationship().user().find('User1');   ","version":"Next","tagName":"h3"},{"title":"HasMany​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#hasmany","content":" The HasMany decorator is used to define a one-to-many relationship between two models. The HasMany decorator takes the target model as an argument.  import { Relational, Model, HasMany } from 'pocketto'; @Relational export class User extends Model { @HasMany('Post') posts!: Post[]; }   You may query the related model using the with method.   const user = await User.query().with('posts').find('User1'); const posts = user.posts;   Or, you may query the related model using the relationship method.  const posts = await User.relationship().posts().find('User1');   ","version":"Next","tagName":"h3"},{"title":"BelongsToMany​","type":1,"pageTitle":"Relationship","url":"/docs/data-modelling/relationship#belongstomany","content":" The BelongsToMany decorator is used to define a many-to-many relationship between two models. The BelongsToMany decorator takes the pivot model and the target model as arguments.  import { Relational, Model, BelongsToMany } from 'pocketto'; @Relational export class User extends Model { @BelongsToMany('UserPost', 'Post') posts!: Post[]; }   You may query the related model using the with method.  const user = await User.query().with('posts').find('User1'); const posts = user.posts;   Or, you may query the related model using the relationship method.  const posts = await User.relationship().posts().find('User1');  ","version":"Next","tagName":"h3"},{"title":"React Hooks","type":0,"sectionRef":"#","url":"/docs/frontend-api/pocketto-react","content":"","keywords":"","version":"Next"},{"title":"React Hooks API​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#react-hooks-api","content":" Pocketto provides a set of React hooks to interact with the Pocketto model in React.  ","version":"Next","tagName":"h2"},{"title":"useRealtimeList​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#userealtimelist","content":" By using useRealtimeList() hook, the listing will auto retrieve new model when there is new data.  import React, { useEffect } from 'react'; import { useRealtimeList } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoiceList() { const invoices = useRealtimeList(SalesInvoice); const navigate = useNavigate(); return &lt;div&gt; {invoices.map((invoice) =&gt; { return &lt;div key={invoice.id} onClick={() =&gt; navigate(`/invoices/${invoice.id}`)}&gt; &lt;h1&gt;{invoice.number}&lt;/h1&gt; &lt;/div&gt;; })} &lt;/div&gt;; }   ","version":"Next","tagName":"h3"},{"title":"useRealtimeList - Configuration​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#userealtimelist---configuration","content":" There is also options that you can pass to useRealtimeList():  animationDelay: Delay in milliseconds to wait your custom animation done. Default: 1ms.condition: A query builder condition to filter and sorting the data.onItemChange: Callback when the item is changed. After the animationDelay is done, it will emit undefined.onItemCreate: Callback when the item is created. After the animationDelay is done, it will emit undefined.onItemUpdate: Callback when the item is updated. After the animationDelay is done, it will emit undefined.  Example:  export function SalesInvoiceList() { const invoices = useRealtimeList(SalesInvoice, { animationDelay: 2000, condition: (query) =&gt; query.where('status', 'draft').orderBy('date', 'desc'), onItemChange: (item) =&gt; console.log('Item changed', item), onItemCreate: (item) =&gt; console.log('Item created', item), onItemUpdate: (item) =&gt; console.log('Item updated', item), }); }   ","version":"Next","tagName":"h3"},{"title":"useRealtime​","type":1,"pageTitle":"React Hooks","url":"/docs/frontend-api/pocketto-react#userealtime","content":" By using useRealtime() hook, it will auto reflected to other similar page that have same model id.  import React, { useEffect } from 'react'; import { useParams } from 'react-router-dom'; import { useRealtime } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoiceList() { const { id } = useParams(); const [invoice, setInvoice] = useRealtime(SalesInvoice, id); return &lt;div&gt; &lt;h1&gt;{invoice?.number}&lt;/h1&gt; &lt;input value={invoice?.number} onChange={(e) =&gt; { setInvoice({ ...invoice, number: e.target.value }); }} /&gt; {/* trigger save to submit to the database */} &lt;button onClick={() =&gt; invoice.save()}&gt;Save&lt;/button&gt; &lt;/div&gt;; }  ","version":"Next","tagName":"h3"},{"title":"Create a Node Module","type":0,"sectionRef":"#","url":"/docs/extra/create-a-node-module","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Create a Node Module","url":"/docs/extra/create-a-node-module#introduction","content":" This is a tutorial to guide you on how to create a Node module. You can create a Node module to share your code with others or to reuse your code in different projects. Such as Node.js, Bun.js or React.js.  Assumption This tutorial is assumed that you source code are all in src folder, an you have a index.ts file in the root directory of your project. If you have a different structure, you can modify the tsconfig.json file to match your project structure.  ","version":"Next","tagName":"h3"},{"title":"Steps​","type":1,"pageTitle":"Create a Node Module","url":"/docs/extra/create-a-node-module#steps","content":" Install the following packages:  npm install -D typescript @types/node ts-node tsconfig-paths eslint eslint-config-airbnb-base eslint-plugin-import jasmine ncp javascript-obfuscator tsc-alias nyc   Add the following scripts to your package.json file:  { &quot;name&quot;: &quot;your-module-name&quot;, &quot;main&quot;: &quot;dist/src/index.js&quot;, &quot;types&quot;: &quot;dist/src/index.d.ts&quot;, &quot;scripts&quot;: { &quot;compile:type&quot;: &quot;tsc --project tsconfig-node.json --declaration --declarationDir dist --emitDeclarationOnly &amp;&amp; tsc-alias -p tsconfig-types.json&quot;, &quot;compile:browser&quot;: &quot;tsc --project tsconfig-browser.json &amp;&amp; tsc-alias -p tsconfig-browser.json &amp;&amp; rm -Rf dist/node/mocks &amp;&amp; rm -Rf dist/node/spec &amp;&amp; rm -Rf dist/node/debug&quot;, &quot;compile:node&quot;: &quot;tsc --project tsconfig-node.json &amp;&amp; tsc-alias -p tsconfig.json &amp;&amp; rm -Rf dist/browser/mocks &amp;&amp; rm -Rf dist/browser/spec &amp;&amp; rm -Rf dist/browser/debug&quot;, &quot;build&quot;: &quot;npm run compile:type &amp;&amp; npm run compile:browser &amp;&amp; npm run compile:node &amp;&amp; npm pack&quot;, } }   Create 3 files in the root directory of your project:  tsconfig-type.json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;src/*&quot;: [ &quot;./src/*&quot; ] }, &quot;lib&quot;: [ &quot;ES2021&quot; ], &quot;outDir&quot;: &quot;./dist&quot;, &quot;sourceMap&quot;: true, &quot;target&quot;: &quot;ES2015&quot;, &quot;module&quot;: &quot;CommonJS&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;esModuleInterop&quot;: true, &quot;declaration&quot;: false, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true }, &quot;include&quot;: [ &quot;src/&quot;, &quot;index.ts&quot;, &quot;**/*.tgz&quot;, &quot;**/*.patch&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/__tests__/*&quot;, &quot;dist&quot;, &quot;spec/&quot;, &quot;mocks/&quot;, ] }   tsconfig-node.json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;src/*&quot;: [ &quot;./src/*&quot; ] }, &quot;lib&quot;: [ &quot;ES2021&quot; ], &quot;outDir&quot;: &quot;./dist/node&quot;, &quot;sourceMap&quot;: true, &quot;target&quot;: &quot;ES2015&quot;, &quot;module&quot;: &quot;CommonJS&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;esModuleInterop&quot;: true, &quot;declaration&quot;: false, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true }, &quot;include&quot;: [ &quot;src/&quot;, &quot;index.ts&quot;, &quot;**/*.tgz&quot;, &quot;**/*.patch&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/__tests__/*&quot;, &quot;dist&quot;, &quot;mocks/&quot;, &quot;spec/&quot; ] }   tsconfig-browser.json { &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;.&quot;, &quot;rootDir&quot;: &quot;.&quot;, &quot;paths&quot;: { &quot;src/*&quot;: [ &quot;./src/*&quot; ] }, &quot;lib&quot;: [ &quot;ES2021&quot; ], &quot;outDir&quot;: &quot;./dist/browser&quot;, &quot;sourceMap&quot;: true, &quot;target&quot;: &quot;ES2015&quot;, &quot;module&quot;: &quot;ES2015&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;resolveJsonModule&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;esModuleInterop&quot;: true, &quot;declaration&quot;: false, &quot;strict&quot;: true, &quot;allowJs&quot;: true, &quot;skipLibCheck&quot;: true }, &quot;include&quot;: [ &quot;src/&quot;, &quot;index.ts&quot;, &quot;**/*.tgz&quot;, &quot;**/*.patch&quot; ], &quot;exclude&quot;: [ &quot;node_modules&quot;, &quot;**/__tests__/*&quot;, &quot;dist&quot;, &quot;spec/&quot;, &quot;mocks/&quot;, ] }   After complete the above steps, you can run the following command to build your module:  npm run build   Then you will get a &lt;your-module-name&gt;.tgz file in the root directory of your project. You can publish this file to npm, or share it with others.  Then run the following command in your destination project to install your module:  npm install &lt;your-module-name&gt;.tgz  ","version":"Next","tagName":"h3"},{"title":"Svelte Stores","type":0,"sectionRef":"#","url":"/docs/frontend-api/pocketto-svelte","content":"","keywords":"","version":"Next"},{"title":"Svelte Stores API​","type":1,"pageTitle":"Svelte Stores","url":"/docs/frontend-api/pocketto-svelte#svelte-stores-api","content":" Pocketto provides a set of Svelte stores to interact with the Pocketto model in Vue.  ","version":"Next","tagName":"h2"},{"title":"useRealtimeList​","type":1,"pageTitle":"Svelte Stores","url":"/docs/frontend-api/pocketto-svelte#userealtimelist","content":" By using useRealtimeList() composable, the listing will auto retrieve new model when there is new data.  &lt;script&gt; import { onDestroy } from 'svelte'; import { goto } from '$app/navigation'; import { useRealtimeList } from 'pocketto-svelte'; import { SalesInvoice } from '../../models/SalesInvoice.p'; let salesInvoices = [] as SalesInvoice[]; const subscriber = useRealtimeList(SalesInvoice); const unsubscribe = subscriber.subscribe((value) =&gt; (salesInvoices = value)); onDestroy(unsubscribe); &lt;/script&gt; {#each salesInvoices as invoice} &lt;div on:click={() =&gt; goto(`/invoices/${invoice.id}`)}&gt; &lt;h1&gt;{invoice.number}&lt;/h1&gt; &lt;/div&gt; {/each}   ","version":"Next","tagName":"h3"},{"title":"useRealtimeList - Configuration​","type":1,"pageTitle":"Svelte Stores","url":"/docs/frontend-api/pocketto-svelte#userealtimelist---configuration","content":" There is also options that you can pass to useRealtimeList():  animationDelay: Delay in milliseconds to wait your custom animation done. Default: 1ms.condition: A query builder condition to filter and sorting the data.onItemChange: Callback when the item is changed. After the animationDelay is done, it will emit undefined.onItemCreate: Callback when the item is created. After the animationDelay is done, it will emit undefined.onItemUpdate: Callback when the item is updated. After the animationDelay is done, it will emit undefined.  Example:  &lt;script&gt; import { onDestroy } from 'svelte'; import { goto } from '$app/navigation'; import { useRealtimeList } from 'pocketto-svelte'; import { SalesInvoice } from '../../models/SalesInvoice.p'; let salesInvoices = [] as SalesInvoice[]; const subscriber = useRealtimeList(SalesInvoice, { animationDelay: 2000, condition: (query) =&gt; query.where('status', 'draft').orderBy('date', 'desc'), onItemChange: (item) =&gt; console.log('Item changed', item), onItemCreate: (item) =&gt; console.log('Item created', item), onItemUpdate: (item) =&gt; console.log('Item updated', item), }); const unsubscribe = subscriber.subscribe((value) =&gt; (salesInvoices = value)); onDestroy(unsubscribe); &lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"useRealtime​","type":1,"pageTitle":"Svelte Stores","url":"/docs/frontend-api/pocketto-svelte#userealtime","content":" By using useRealtime() hook, it will auto reflected to other similar page that have same model id.  &lt;script&gt; import { onDestroy } from 'svelte'; import { useParams } from 'svelte-routing'; import { useRealtime } from 'pocketto-svelte'; import { SalesInvoice } from '../../models/SalesInvoice.p'; let invoice: SalesInvoice; const { id } = useParams(); const subscriber = useRealtime(SalesInvoice, id); const unsubscribe = subscriber.subscribe((value) =&gt; (invoice = value)); onDestroy(unsubscribe); &lt;/script&gt; &lt;div&gt; &lt;h1&gt;{invoice?.number}&lt;/h1&gt; &lt;input type=&quot;text&quot; bind:value={invoice.number} /&gt; {/* trigger save to submit to the database */} &lt;button on:click={() =&gt; invoice.save()}&gt;Save&lt;/button&gt; &lt;/div&gt;  ","version":"Next","tagName":"h3"},{"title":"React Native Hooks","type":0,"sectionRef":"#","url":"/docs/frontend-api/pocketto-react-native","content":"","keywords":"","version":"Next"},{"title":"React Hooks API​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#react-hooks-api","content":" Pocketto provides a set of React hooks to interact with the Pocketto model in React Native.  ","version":"Next","tagName":"h2"},{"title":"useRealtimeList​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#userealtimelist","content":" By using useRealtimeList() hook, the listing will auto retrieve new model when there is new data.  import React, { useEffect } from 'react'; import { Pressable, Text, View } from &quot;react-native&quot;; import { useRoute } from &quot;@react-navigation/native&quot;; import { NativeStackScreenProps } from &quot;@react-navigation/native-stack&quot;; import { useRealtimeList } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoiceList({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const invoices = useRealtimeList(SalesInvoice); return &lt;View&gt; {invoices.map((invoice) =&gt; { const onPress = () =&gt; { navigation.navigate('SalesInvoicePage', { id: invoice.id }); }; return &lt;Pressable key={invoice.id} onPress={onPress}&gt; &lt;Text&gt;{invoice.number}&lt;/Text&gt; &lt;/Pressable&gt;; })} &lt;/View&gt;; }   ","version":"Next","tagName":"h3"},{"title":"useRealtimeList - Configuration​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#userealtimelist---configuration","content":" There is also options that you can pass to useRealtimeList():  animationDelay: Delay in milliseconds to wait your custom animation done. Default: 1ms.condition: A query builder condition to filter and sorting the data.onItemChange: Callback when the item is changed. After the animationDelay is done, it will emit undefined.onItemCreate: Callback when the item is created. After the animationDelay is done, it will emit undefined.onItemUpdate: Callback when the item is updated. After the animationDelay is done, it will emit undefined.  Example:  export function SalesInvoiceList({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const invoices = useRealtimeList(SalesInvoice, { animationDelay: 2000, condition: (query) =&gt; query.where('status', 'draft').orderBy('date', 'desc'), onItemChange: (item) =&gt; console.log('Item changed', item), onItemCreate: (item) =&gt; console.log('Item created', item), onItemUpdate: (item) =&gt; console.log('Item updated', item), }); }   ","version":"Next","tagName":"h3"},{"title":"useRealtime​","type":1,"pageTitle":"React Native Hooks","url":"/docs/frontend-api/pocketto-react-native#userealtime","content":" By using useRealtime() hook, it will auto reflected the data that have same model id in other opened screen.  import React, { useEffect } from 'react'; import { Pressable, Text, View } from &quot;react-native&quot;; import { useRoute } from &quot;@react-navigation/native&quot;; import { NativeStackScreenProps } from &quot;@react-navigation/native-stack&quot;; import { useRealtime } from 'pocketto-react'; import { SalesInvoice } from 'src/models/SalesInvoice.p'; export function SalesInvoicePage({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const route = useRoute(); const { id } = route.params; const [invoice, setInvoice] = useRealtime(SalesInvoice, id); return &lt;View&gt; &lt;Text&gt;{invoice?.number}&lt;/Text&gt; &lt;TextInput value={invoice?.number} onTextChange={(value) =&gt; { setInvoice({ ...invoice, number: value }); }} /&gt; {/* trigger save to submit to the database */} &lt;Pressable onPress={() =&gt; invoice.save()}&gt;Save&lt;/Pressable&gt; &lt;/View&gt;; }   You can use the useEffect to listen if the model._meta._rev is changed, so you can show some message to user that the data is updated.  export function SalesInvoicePage({ navigation, }: { navigation: NativeStackScreenProps&lt;any&gt;['navigation']; }) { const [invoice, setInvoice] = useRealtime(SalesInvoice, id); const [rev, setRev] = useState(''); useEffect(() =&gt; { if (invoice._meta._rev !== rev &amp;&amp; rev &amp;&amp; invoice._meta._rev) { console.log('Data updated'); } else { setRev(invoice._meta._rev); } }, [invoice._meta._rev, rev]); }  ","version":"Next","tagName":"h3"},{"title":"Vue Composables","type":0,"sectionRef":"#","url":"/docs/frontend-api/pocketto-vue","content":"","keywords":"","version":"Next"},{"title":"Vue Composables API​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#vue-composables-api","content":" Pocketto provides a set of Vue composables to interact with the Pocketto model in Vue.  ","version":"Next","tagName":"h2"},{"title":"useRealtimeList​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#userealtimelist","content":" By using useRealtimeList() composable, the listing will auto retrieve new model when there is new data.  &lt;script setup lang=&quot;ts&quot;&gt; import { SalesInvoice } from '@/models/SalesInvoice.p'; import { ref } from 'vue'; import { useRouter } from 'vue-router'; import { useRealtimeList } from 'pocketto-vue'; const changedItem = ref&lt;SalesInvoice&gt;(); const salesInvoices = useRealtimeList(SalesInvoice, { animationDelay: 3000, itemChange: (item) =&gt; { changedItem.value = item; }, }); const router = useRouter(); function navigateToInvoice(invoice: SalesInvoice) { router.push(`/invoices/${invoice.id}`); } &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;div v-for=&quot;invoice in salesInvoices&quot; :key=&quot;invoice.id&quot; @click=&quot;navigateToInvoice(invoice)&quot;&gt; &lt;h1&gt;{{ invoice.number }}&lt;/h1&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;   ","version":"Next","tagName":"h3"},{"title":"useRealtimeList - Configuration​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#userealtimelist---configuration","content":" There is also options that you can pass to useRealtimeList():  animationDelay: Delay in milliseconds to wait your custom animation done. Default: 1ms.condition: A query builder condition to filter and sorting the data.onItemChange: Callback when the item is changed. After the animationDelay is done, it will emit undefined.onItemCreate: Callback when the item is created. After the animationDelay is done, it will emit undefined.onItemUpdate: Callback when the item is updated. After the animationDelay is done, it will emit undefined.  Example:  &lt;script setup lang=&quot;ts&quot;&gt; import { SalesInvoice } from '@/models/SalesInvoice.p'; import { ref } from 'vue'; import { useRealtimeList } from 'pocketto-vue'; const changedItem = ref&lt;SalesInvoice&gt;(); const salesInvoices = useRealtimeList(SalesInvoice, { animationDelay: 3000, condition: (query) =&gt; query.where('status', 'draft').orderBy('date', 'desc'), itemChange: (item) =&gt; { changedItem.value = item; }, }); &lt;/script&gt;   ","version":"Next","tagName":"h3"},{"title":"useRealtime​","type":1,"pageTitle":"Vue Composables","url":"/docs/frontend-api/pocketto-vue#userealtime","content":" By using useRealtime() hook, it will auto reflected to other similar page that have same model id.  &lt;script setup lang=&quot;ts&quot;&gt; import { SalesInvoice } from '@/models/SalesInvoice.p'; import { ref } from 'vue'; import { useRealtime } from 'pocketto-vue'; const route = useRoute(); const router = useRouter(); const id = route.params.id; const invoice = useRealtime(SalesInvoice, id); watch(() =&gt; route.params.id, (newId, oldId) =&gt; { if (newId !== oldId) { invoice = useRealtime(SalesInvoice, newId as string); } }); &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;h1&gt;{{ invoice.number }}&lt;/h1&gt; &lt;input v-model=&quot;invoice.number&quot; /&gt; {/* trigger save to submit to the database */} &lt;button @click=&quot;invoice.save()&quot;&gt;Save&lt;/button&gt; &lt;/div&gt; &lt;/template&gt;  ","version":"Next","tagName":"h3"},{"title":"React Native","type":0,"sectionRef":"#","url":"/docs/installation/frontend/react-native","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"React Native","url":"/docs/installation/frontend/react-native#installation","content":" To use Pocketto in a React Native project, you need to install the pocketto and pocketto-react package.  npm install pocketto pocketto-react   warning You might facing issue when install the package. In this case, please refer to this solution.  Also, to install native dependencies in order to let pocketto work properly, you need to install the following packages.  npm install -D @babel/plugin-proposal-decorators @babel/plugin-transform-class-static-block babel-plugin-module-resolver babel-plugin-transform-decorators-legacy rn-nodeify npm install @tradle/react-native-http assert buffer https-browserify path-browserify process react-native-crypto react-native-get-random-values react-native-level-fs react-native-os react-native-randombytes react-native-sqlite-2 readable-stream stream-browserify url base-64 pouchdb-adapter-react-native-sqlite@3.0.1   Add postinstall script to your package.json file.  package.json { &quot;scripts&quot;: { &quot;postinstall&quot;: &quot;rn-nodeify --install fs,process,url,assert,crypto,http,https,os,buffer,stream,path --hack&quot; } }   Add shim.js file to the root of your project.  shim.js import { shim } from 'react-native-quick-base64'; shim(); if (typeof __dirname === 'undefined') global.__dirname = '/'; if (typeof __filename === 'undefined') global.__filename = ''; if (typeof process === 'undefined') { global.process = require('process'); } else { const bProcess = require('process'); for (var p in bProcess) { if (!(p in process)) { process[p] = bProcess[p]; } } } process.browser = false; process.nextTick = setImmediate; if (typeof Buffer === 'undefined') global.Buffer = require('buffer').Buffer; const isDev = typeof __DEV__ === 'boolean' &amp;&amp; __DEV__; process.env['NODE_ENV'] = isDev ? 'development' : 'production'; if (typeof localStorage !== 'undefined') { localStorage.debug = isDev ? '*' : ''; } // If using the crypto shim, uncomment the following line to ensure // crypto is loaded first, so it can populate global.crypto // require('crypto')   Make sure you are enabled decorators in your project. If not, you can enable it by adding the following configuration to your tsconfig.json file.  tsconfig.json { &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"iOS Configuration​","type":1,"pageTitle":"React Native","url":"/docs/installation/frontend/react-native#ios-configuration","content":" For iOS, make sure you are running pod install after installing the packages for native dependencies.  npx pod-install   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"React Native","url":"/docs/installation/frontend/react-native#usage","content":" You can connect to a database via the DatabaseManager.connect() function. Also, you need to set the environment to react-native. You can also set the id method to timestamp which is optional. All available id method in here.  You also need to manually install the SQLite adapter for PouchDB.  index.js import { AppRegistry } from 'react-native'; import App from './App'; import 'react-native-get-random-values'; import PouchDB from 'pouchdb'; import SQLiteAdapterFactory from 'pouchdb-adapter-react-native-sqlite'; import SQLite from 'react-native-sqlite-2'; import { DatabaseManager, p } from &quot;pocketto&quot;; const SQLiteAdapter = SQLiteAdapterFactory(SQLite); PouchDB.plugin(SQLiteAdapter); p.setEnvironment(&quot;react-native&quot;); p.setIdMethod('timestamp'); DatabaseManager.connect('default', { adapter: 'react-native-sqlite', dbName: 'default' }).then((localDb) =&gt; { const remoteHost = Platform.OS === 'android' ? 'http://192.168.68.107:5984' : 'http://localhost:5984'; p.setRealtime(true); }); AppRegistry.registerComponent(appName, () =&gt; App);  ","version":"Next","tagName":"h3"},{"title":"React","type":0,"sectionRef":"#","url":"/docs/installation/frontend/react","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"React","url":"/docs/installation/frontend/react#installation","content":" To use Pocketto in a React project, you need to install the pocketto and pocketto-react package.  npm install pocketto pocketto-react   warning You might facing issue when install the package. In this case, please refer to this solution.  Make sure you are enabled decorators in your project. If not, you can enable it by adding the following configuration to your tsconfig.json file.  tsconfig.json { &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Using Vite​","type":1,"pageTitle":"React","url":"/docs/installation/frontend/react#using-vite","content":" If you are using vite, make sure you have enable global and decorators in vite.config.ts file.  vite.config.ts import { defineConfig } from 'vite' import react from '@vitejs/plugin-react' export default defineConfig({ plugins: [react({ babel: { plugins: [ [&quot;@babel/plugin-proposal-decorators&quot;, { legacy: true }], [ &quot;@babel/plugin-proposal-class-properties&quot;, { loose: true }, ], ], }, })], define: { global: {}, } });   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"React","url":"/docs/installation/frontend/react#usage","content":" You can connect to a database via the DatabaseManager.connect() function. Also, you need to set the environment to browser. You can also set the id method to timestamp which is optional. All available id method in here.  src/main.tsx import { createRoot } from 'react-dom/client' import App from './App.tsx' import './index.css' import { DatabaseManager, p } from 'pocketto' p.setEnvironment('browser'); p.setIdMethod('timestamp'); DatabaseManager.connect('default', { dbName: 'default', }).then(async (localDb) =&gt; { p.setRealtime(true); }); createRoot(document.getElementById('root')).render( &lt;StrictMode&gt; &lt;App /&gt; &lt;/StrictMode&gt;, );  ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Highlights​","type":1,"pageTitle":"Introduction","url":"/docs/intro#highlights","content":" Offline First Architecture: You can use Pocketto without internet connection. Even in web application.Real Time Syncing: Sync your data across different platforms.Run with different javascript environment: Pocketto can run in different javascript environment like Node.js, Browser, React Native, so you don't need to rewrite your business logic in different platform.Encrypted: Pocketto allow you to encrypts your data and store it locally.Open Source: Pocketto is open source so everybody can use it and inspect the code to prevent any security issues.  ","version":"Next","tagName":"h3"},{"title":"Getting Started​","type":1,"pageTitle":"Introduction","url":"/docs/intro#getting-started","content":" To get started, click here to proceed.  ","version":"Next","tagName":"h3"},{"title":"Examples​","type":1,"pageTitle":"Introduction","url":"/docs/intro#examples","content":" You can download and setup the example project from below: Frontend:   React Example React Native Example Vue Example Svelte Example   Backend:   Bun Example  ","version":"Next","tagName":"h3"},{"title":"Vue","type":0,"sectionRef":"#","url":"/docs/installation/frontend/vue","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Vue","url":"/docs/installation/frontend/vue#installation","content":" To use Pocketto in a Vue project, you need to install the pocketto and pocketto-vue package.  npm install pocketto pocketto-vue   warning You might facing issue when install the package. In this case, please refer to this solution.  Make sure you are enabled decorators in your project. If not, you can enable it by adding the following configuration to your tsconfig.json file.  tsconfig.json { &quot;compilerOptions&quot;: { &quot;experimentalDecorators&quot;: true } }   ","version":"Next","tagName":"h3"},{"title":"Using Vite​","type":1,"pageTitle":"Vue","url":"/docs/installation/frontend/vue#using-vite","content":" If you are using vite, make sure you have enable global and decorators in vite.config.ts file.  vite.config.ts import { fileURLToPath, URL } from 'node:url' import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' export default defineConfig({ plugins: [ vue(), ], resolve: { alias: { '@': fileURLToPath(new URL('./src', import.meta.url)) } }, define: { global: {}, }, })   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Vue","url":"/docs/installation/frontend/vue#usage","content":" You can connect to a database via the DatabaseManager.connect() function. Also, you need to set the environment to browser. You can also set the id method to timestamp which is optional. All available id method in here.  src/main.ts import { createApp } from 'vue' import App from './App.vue' import router from './router' import { DatabaseManager, p } from 'pocketto' p.setEnvironment('browser'); p.setIdMethod('timestamp'); DatabaseManager.connect('default', { dbName: 'default', }).then(() =&gt; { p.setRealtime(true); }); const app = createApp(App) app.mount('#app')  ","version":"Next","tagName":"h3"},{"title":"Svelte","type":0,"sectionRef":"#","url":"/docs/installation/frontend/svelte","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Svelte","url":"/docs/installation/frontend/svelte#installation","content":" To use Pocketto in a Svelte project, you need to install the pocketto and pocketto-svelte package. Also, need to install patch-package to patch the pouchdb-browser to fix package.  npm install pocketto pocketto-svelte patch-package   After installing the package, you need to patch the pouchdb-browser package. You can do this by running the following command.  mkdir patches cp node_modules/pocketto-svelte/patches/pouchdb-browser+8.0.1.patch patches/   Add the following script to your package.json file.  package.json { &quot;scripts&quot;: { &quot;postinstall&quot;: &quot;patch-package&quot; } }   Then, run the following command to patch the pouchdb-browser package.  npm install   warning You might facing issue when install the package. In this case, please refer to this solution.  ","version":"Next","tagName":"h3"},{"title":"Using Vite​","type":1,"pageTitle":"Svelte","url":"/docs/installation/frontend/svelte#using-vite","content":" If you are using vite, make sure you have enable global and decorators in vite.config.ts file.  vite.config.ts import { sveltekit } from '@sveltejs/kit/vite'; import { defineConfig } from 'vite'; export default defineConfig({ plugins: [sveltekit()], define: { global: {}, }, });   Disable the ssr in the +layout.ts file.  src/+layout.ts export const ssr = false;   ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Svelte","url":"/docs/installation/frontend/svelte#usage","content":" You can connect to a database via the DatabaseManager.connect() function. Also, you need to set the environment to browser. You can also set the id method to timestamp which is optional. All available id method in here.  src/+layout.svelte &lt;script lang=&quot;ts&quot;&gt; import Header from './Header.svelte'; import '../app.css'; let { children } = $props(); import { DatabaseManager, p } from 'pocketto'; p.setEnvironment('browser'); p.setIdMethod('timestamp'); DatabaseManager.connect('default', { dbName: 'default', adapter: 'idb' }).then(async (localDb) =&gt; { p.setRealtime(true); }); &lt;/script&gt; &lt;div class=&quot;app&quot;&gt; &lt;Header /&gt; &lt;main&gt; {@render children()} &lt;/main&gt; &lt;footer&gt; &lt;p&gt; visit &lt;a href=&quot;https://svelte.dev/docs/kit&quot;&gt;svelte.dev/docs/kit&lt;/a&gt; to learn about SvelteKit &lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;style&gt; .app { display: flex; flex-direction: column; min-height: 100vh; } main { flex: 1; display: flex; flex-direction: column; padding: 1rem; width: 100%; max-width: 64rem; margin: 0 auto; box-sizing: border-box; } footer { display: flex; flex-direction: column; justify-content: center; align-items: center; padding: 12px; } footer a { font-weight: bold; } @media (min-width: 480px) { footer { padding: 12px 0; } } &lt;/style&gt;  ","version":"Next","tagName":"h3"},{"title":"Bun + Elysia.js","type":0,"sectionRef":"#","url":"/docs/installation/backend/bun","content":"","keywords":"","version":"Next"},{"title":"Prerequisites​","type":1,"pageTitle":"Bun + Elysia.js","url":"/docs/installation/backend/bun#prerequisites","content":" tip We are using MongoDB as the database for this project. You can use any database you prefer.  Before you start setting up your environment, make sure you have the following installed:  Bun, a superfast and new javascript runtime, natively support typescript.MongoDB, a NoSQL database that popular by using MERN stack.  ","version":"Next","tagName":"h3"},{"title":"Installation​","type":1,"pageTitle":"Bun + Elysia.js","url":"/docs/installation/backend/bun#installation","content":" Start by creating a new project using Bun CLI.  bun create elysia my-bun-app cd my-bun-app   Next, install the required dependencies. And install the MongoDB driver, and pocketto dependencies.  bun install bun add mongoose pocketto   ","version":"Next","tagName":"h3"},{"title":"Configuration​","type":1,"pageTitle":"Bun + Elysia.js","url":"/docs/installation/backend/bun#configuration","content":" Make sure you are setup your CouchDB to support couch_peruser, so the database will automatically create a new database for each user created.  ","version":"Next","tagName":"h3"},{"title":"Usage​","type":1,"pageTitle":"Bun + Elysia.js","url":"/docs/installation/backend/bun#usage","content":" To start, create a file src/models/master/Database.ts and add the following code:  Add the dependencies file from below:  src/utils/couchdb.ts, heresrc/utils/database.ts, here  src/models/master/Database.ts import * as mongoose from 'mongoose'; import initiateCouchDB from '../../utils/couchdb'; import createUser, { connectSlaveDb } from '../../utils/database'; import Company from './Company'; export type Database = { name: string; protocol: string; databasableType: string; databasableId: mongoose.Types.ObjectId; host: string; port: number; username: string; password: string; database: string; encryption: boolean; encryptionPassword: string; }; const DatabaseSchema = new mongoose.Schema({ name: { type: String, required: true, }, protocol: { type: String, default: 'http', }, databasableType: { type: String, required: true, }, databasableId: { type: mongoose.Schema.Types.ObjectId, required: true, }, host: { type: String, required: true, }, port: { type: Number, required: true, }, username: { type: String, required: true, }, password: { type: String, required: true, }, database: { type: String, required: true, }, encryption: { type: Boolean, default: false, }, encryptionPassword: { type: String, }, }, { statics: { async checkDatabaseAccess(databaseId: string, userId: string, set) { const database = await this.findOne({ _id: databaseId }); if (!database) return; if (database.databasableType === 'User' &amp;&amp; database.databasableId.toString() !== userId) { set.status = 403; return { message: &quot;Unauthorized&quot;, } } if (database.databasableType === 'Company') { const invalidAccess = await Company.checkCompanyAccess(database.databasableId.toString(), userId, set); if (invalidAccess) { return invalidAccess; } } }, }, methods: { createUserAndDatabase: async function () { const host = Bun.env.COUCHDB_HOST as string; const auth = { username: Bun.env.COUCHDB_USERNAME as string, password: Bun.env.COUCHDB_PASSWORD as string, }; await initiateCouchDB(host, auth); await createUser(host, this.username, this.password, auth); }, async connect() { return connectSlaveDb(this.toJSON() as Database); }, }, toJSON: { virtuals: true, versionKey: false, transform: (_, ret) =&gt; { ret.id = ret._id; delete ret._id; } }, }); export default mongoose.model('Database', DatabaseSchema);   You can now bind the database into any master model you want to use. For example, you can bind the database into the Company or User master model.  src/models/master/Company.ts, heresrc/models/master/User.ts, here  Also, in this example, we are using the SalesInvoice and Guide slave model.  src/models/slave/SalesInvoice.p.ts, heresrc/models/slave/Guide.p.ts, here  Then, you can expose the API for the database model. Example from here  src/modules/DatabaseModule.ts import { ProtectedApp } from &quot;..&quot;; import createUser, { connectMasterDb, usernameToDbName } from &quot;../utils/database&quot;; import Database from &quot;../models/master/Database&quot;; import { t } from &quot;elysia&quot;; import mongoose from &quot;mongoose&quot;; import initiateCouchDB from &quot;../utils/couchdb&quot;; import shortUuid from 'short-uuid'; import { SalesInvoice } from &quot;../models/slave/SalesInvoice.p&quot;; import { Guide } from &quot;../models/slave/Guide.p&quot;; import { Model } from &quot;pocketto&quot;; import { ModelStatic } from &quot;pocketto/dist/src/definitions/Model&quot;; enum DatabasableType { User = &quot;User&quot;, Company = &quot;Company&quot;, }; const List = (app: ProtectedApp) =&gt; { return app.get( &quot;/&quot;, async ({ userId }) =&gt; { await connectMasterDb(); const databases = await Database.find({ databasableId: userId }); return { message: &quot;Databases retrieved successfully&quot;, data: databases.map((database) =&gt; database.toJSON()), }; }, ); } const Read = (app: ProtectedApp) =&gt; { return app.get( &quot;/:databaseId&quot;, async ({ set, userId, params: { databaseId } }) =&gt; { await connectMasterDb(); const database = await Database.findOne({ _id: databaseId }); if (!database) { set.status = 404; return { message: &quot;Database not found&quot;, }; } const invalidAccess = await Database.checkDatabaseAccess(databaseId, userId, set); if (invalidAccess) { return invalidAccess; } return { message: &quot;Database retrieved successfully&quot;, data: database.toJSON(), }; }, ); } const Create = (app: ProtectedApp) =&gt; { return app.post( &quot;/&quot;, async ({ body, userId }) =&gt; { await connectMasterDb(); const username = String(shortUuid.generate()); const password = String(shortUuid.generate()); const databaseName = usernameToDbName(username); const database = new Database(); database.databasableType = body.databasableType || &quot;User&quot;; database.databasableId = new mongoose.Types.ObjectId(body.databasableId || userId); database.name = `${database.databasableType}-${database.databasableId}`; database.protocol = Bun.env.COUCHDB_PROTOCOL as string; database.host = Bun.env.COUCHDB_HOST as string; database.port = Number(Bun.env.COUCHDB_PORT); database.username = username; database.password = password; database.database = databaseName; database.encryption = body.encryption || false; database.encryptionPassword = body.encryptionPassword || &quot;&quot;; await database.save(); const host = Bun.env.COUCHDB_HOST as string; const auth = { username: Bun.env.COUCHDB_USERNAME as string, password: Bun.env.COUCHDB_PASSWORD as string, }; await initiateCouchDB(host, auth); const url = `${database.protocol}://${database.host}:${database.port}`; await createUser(url, database.username, database.password, auth); await new Promise((resolve) =&gt; setTimeout(resolve, 50)); return { message: &quot;Database created successfully&quot;, data: database.toJSON(), }; }, ); } const ReadDocuments = (app: ProtectedApp) =&gt; { return app.get( &quot;/:databaseId/collections/:collectionName/documents&quot;, async ({ set, userId, params: { databaseId, collectionName } }) =&gt; { await connectMasterDb(); const database = await Database.findOne({ _id: databaseId }); if (!database) { set.status = 404; return { message: &quot;Database not found&quot;, }; } const invalidAccess = await Database.checkDatabaseAccess(databaseId, userId, set); if (invalidAccess) { return invalidAccess; } const collectionMapper = { [SalesInvoice.collectionName]: SalesInvoice, [Guide.collectionName]: Guide, } as { [key: string]: ModelStatic&lt;Model&gt; }; if (!collectionMapper[collectionName]) { set.status = 404; return { message: &quot;Collection not found&quot;, }; } await database.connect(); const DestinationModel = collectionMapper[collectionName]; const databaseName = database.name; const result = await (new DestinationModel()).getClass().via(databaseName).get(); return { message: &quot;Collection list retrieved successfully&quot;, data: result, }; }, ); } const ReadDocument = (app: ProtectedApp) =&gt; { return app.get( &quot;/:databaseId/collections/:collectionName/documents/:documentId&quot;, async ({ set, userId, params: { databaseId, collectionName, documentId } }) =&gt; { await connectMasterDb(); const database = await Database.findOne({ _id: databaseId }); if (!database) { set.status = 404; return { message: &quot;Database not found&quot;, }; } const invalidAccess = await Database.checkDatabaseAccess(databaseId, userId, set); if (invalidAccess) { return invalidAccess; } const collectionMapper = { [SalesInvoice.collectionName]: SalesInvoice, [Guide.collectionName]: Guide, } as { [key: string]: ModelStatic&lt;Model&gt; }; if (!collectionMapper[collectionName]) { set.status = 404; return { message: &quot;Collection not found&quot;, }; } await database.connect(); const DestinationModel = collectionMapper[collectionName]; const databaseName = database.name; const result = await (new DestinationModel()).getClass().via(databaseName).find(documentId); if (!result) { set.status = 404; return { message: &quot;Document not found&quot;, }; } return { message: &quot;Document retrieved successfully&quot;, data: result, }; }, ); } const CreateDocument = (app: ProtectedApp) =&gt; { return app.post( &quot;/:databaseId/collections/:collectionName/documents&quot;, async ({ set, userId, params: { databaseId, collectionName }, body }) =&gt; { await connectMasterDb(); const database = await Database.findOne({ _id: databaseId }); if (!database) { set.status = 404; return { message: &quot;Database not found&quot;, }; } const invalidAccess = await Database.checkDatabaseAccess(databaseId, userId, set); if (invalidAccess) { return invalidAccess; } const collectionMapper = { [SalesInvoice.collectionName]: SalesInvoice, [Guide.collectionName]: Guide, } as { [key: string]: ModelStatic&lt;Model&gt; }; if (!collectionMapper[collectionName]) { set.status = 404; return { message: &quot;Collection not found&quot;, }; } await database.connect(); const DestinationModel = collectionMapper[collectionName]; const databaseName = database.name; const createResult = await (new DestinationModel()).getClass().via(databaseName).create(body); const result = await (new DestinationModel()).getClass().via(databaseName).find(createResult._id); return { message: &quot;Document created successfully&quot;, data: result, }; }, ); } const UpdateDocument = (app: ProtectedApp) =&gt; { return app.put( &quot;/:databaseId/collections/:collectionName/documents/:documentId&quot;, async ({ set, userId, params: { databaseId, collectionName, documentId }, body }) =&gt; { await connectMasterDb(); const database = await Database.findOne({ _id: databaseId }); if (!database) { set.status = 404; return { message: &quot;Database not found&quot;, }; } const invalidAccess = await Database.checkDatabaseAccess(databaseId, userId, set); if (invalidAccess) { return invalidAccess; } const collectionMapper = { [SalesInvoice.collectionName]: SalesInvoice, [Guide.collectionName]: Guide, } as { [key: string]: ModelStatic&lt;Model&gt; }; if (!collectionMapper[collectionName]) { set.status = 404; return { message: &quot;Collection not found&quot;, }; } await database.connect(); const DestinationModel = collectionMapper[collectionName]; const databaseName = database.name; const result = await (new DestinationModel()).getClass().via(databaseName).find(documentId); if (!result) { set.status = 404; return { message: &quot;Document not found&quot;, }; } result.fill(body); result.getClass().dbName = databaseName; await result.save(); return { message: &quot;Document updated successfully&quot;, data: result, }; }, ); } export default { List, Read, Create, ReadDocuments, ReadDocument, CreateDocument, UpdateDocument, };   And then, we can expose these API to the server.  src/index.ts const app = new Elysia() .group(&quot;/databases&quot;, (group) =&gt; group .use(DatabaseModule.List) .use(DatabaseModule.Read) .use(DatabaseModule.Create) .use(DatabaseModule.ReadDocuments) .use(DatabaseModule.ReadDocument) .use(DatabaseModule.CreateDocument) .use(DatabaseModule.UpdateDocument) ); app.listen(3000); console.log(&quot;Server started at http://localhost:3000&quot;);   You can now start the server by running the following command:  bun dev   It will output the following:  Server started at http://localhost:3000  ","version":"Next","tagName":"h3"}],"options":{"languages":["en"],"id":"default"}}